// Code generated by protoc-gen-go. DO NOT EDIT.
// source: btcrpc.proto

/*
Package btcrpc is a generated protocol buffer package.

It is generated from these files:
	btcrpc.proto

It has these top-level messages:
	Block
	BlockInfo
	BlockLocator
	NodeInfo
	Transaction
	TransactionFilter
	MempoolTransaction
	UnspentOutput
	BlockNotification
	TransactionNotification
	ConnectPeerRequest
	ConnectPeerResponse
	SetDebugLevelRequest
	SetDebugLevelResponse
	DisconnectPeerRequest
	DisconnectPeerResponse
	GenerateBlocksRequest
	GenerateBlocksResponse
	GetBestBlockInfoRequest
	GetBestBlockInfoResponse
	GetBlockRequest
	GetBlockResponse
	GetBlockCountRequest
	GetBlockCountResponse
	GetBlockInfoRequest
	GetBlockInfoResponse
	GetGenerateInfoRequest
	GetGenerateInfoResponse
	GetMempoolRequest
	GetMempoolResponse
	GetMempoolInfoRequest
	GetMempoolInfoResponse
	GetMiningInfoRequest
	GetMiningInfoResponse
	GetNetworkHashRateRequest
	GetNetworkHashRateResponse
	GetNetworkInfoRequest
	GetNetworkInfoResponse
	GetPeersRequest
	GetPeersResponse
	GetRawBlockRequest
	GetRawBlockResponse
	GetRawMempoolRequest
	GetRawMempoolResponse
	GetRawTransactionRequest
	GetRawTransactionResponse
	GetSystemInfoRequest
	GetSystemInfoResponse
	GetTransactionRequest
	GetTransactionResponse
	RemoveNodeRequest
	RemoveNodeResponse
	RescanBlocksRequest
	RescanTransactionsRequest
	SetGenerateRequest
	SetGenerateResponse
	SearchTransactionsRequest
	SearchTransactionsResponse
	SubmitTransactionRequest
	SubmitTransactionResponse
	GetAddressTransactionsRequest
	GetAddressTransactionsResponse
	GetAddressUnspentOutputsRequest
	GetAddressUnspentOutputsResponse
	SubmitBlockRequest
	SubmitBlockResponse
	SubscribeBlocksRequest
	SubscribeTransactionsRequest
	StopDaemonRequest
	StopDaemonResponse
*/
package btcrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NodeInfo_ConnectedStatus int32

const (
	NodeInfo_DISCONNECTED NodeInfo_ConnectedStatus = 0
	NodeInfo_OUTBOUND     NodeInfo_ConnectedStatus = 1
	NodeInfo_INBOUND      NodeInfo_ConnectedStatus = 2
)

var NodeInfo_ConnectedStatus_name = map[int32]string{
	0: "DISCONNECTED",
	1: "OUTBOUND",
	2: "INBOUND",
}
var NodeInfo_ConnectedStatus_value = map[string]int32{
	"DISCONNECTED": 0,
	"OUTBOUND":     1,
	"INBOUND":      2,
}

func (x NodeInfo_ConnectedStatus) String() string {
	return proto.EnumName(NodeInfo_ConnectedStatus_name, int32(x))
}
func (NodeInfo_ConnectedStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type BlockNotification_Type int32

const (
	BlockNotification_CONNECTED    BlockNotification_Type = 0
	BlockNotification_DISCONNECTED BlockNotification_Type = 1
)

var BlockNotification_Type_name = map[int32]string{
	0: "CONNECTED",
	1: "DISCONNECTED",
}
var BlockNotification_Type_value = map[string]int32{
	"CONNECTED":    0,
	"DISCONNECTED": 1,
}

func (x BlockNotification_Type) String() string {
	return proto.EnumName(BlockNotification_Type_name, int32(x))
}
func (BlockNotification_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

type TransactionNotification_Type int32

const (
	TransactionNotification_ACCEPTED  TransactionNotification_Type = 0
	TransactionNotification_CONFIRMED TransactionNotification_Type = 1
)

var TransactionNotification_Type_name = map[int32]string{
	0: "ACCEPTED",
	1: "CONFIRMED",
}
var TransactionNotification_Type_value = map[string]int32{
	"ACCEPTED":  0,
	"CONFIRMED": 1,
}

func (x TransactionNotification_Type) String() string {
	return proto.EnumName(TransactionNotification_Type_name, int32(x))
}
func (TransactionNotification_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{9, 0}
}

type SetDebugLevelRequest_DebugLevel int32

const (
	SetDebugLevelRequest_TRACE    SetDebugLevelRequest_DebugLevel = 0
	SetDebugLevelRequest_DEBUG    SetDebugLevelRequest_DebugLevel = 1
	SetDebugLevelRequest_INFO     SetDebugLevelRequest_DebugLevel = 2
	SetDebugLevelRequest_WARN     SetDebugLevelRequest_DebugLevel = 3
	SetDebugLevelRequest_ERROR    SetDebugLevelRequest_DebugLevel = 4
	SetDebugLevelRequest_CRITICAL SetDebugLevelRequest_DebugLevel = 5
)

var SetDebugLevelRequest_DebugLevel_name = map[int32]string{
	0: "TRACE",
	1: "DEBUG",
	2: "INFO",
	3: "WARN",
	4: "ERROR",
	5: "CRITICAL",
}
var SetDebugLevelRequest_DebugLevel_value = map[string]int32{
	"TRACE":    0,
	"DEBUG":    1,
	"INFO":     2,
	"WARN":     3,
	"ERROR":    4,
	"CRITICAL": 5,
}

func (x SetDebugLevelRequest_DebugLevel) String() string {
	return proto.EnumName(SetDebugLevelRequest_DebugLevel_name, int32(x))
}
func (SetDebugLevelRequest_DebugLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 0}
}

type SetDebugLevelRequest_Subsystem int32

const (
	SetDebugLevelRequest_ALL  SetDebugLevelRequest_Subsystem = 0
	SetDebugLevelRequest_ADXR SetDebugLevelRequest_Subsystem = 1
	SetDebugLevelRequest_AMGR SetDebugLevelRequest_Subsystem = 2
	SetDebugLevelRequest_CMGR SetDebugLevelRequest_Subsystem = 3
	SetDebugLevelRequest_BCDB SetDebugLevelRequest_Subsystem = 4
	SetDebugLevelRequest_BTCD SetDebugLevelRequest_Subsystem = 5
	SetDebugLevelRequest_CHAN SetDebugLevelRequest_Subsystem = 6
	SetDebugLevelRequest_DISC SetDebugLevelRequest_Subsystem = 7
	SetDebugLevelRequest_INDX SetDebugLevelRequest_Subsystem = 8
	SetDebugLevelRequest_MINR SetDebugLevelRequest_Subsystem = 9
	SetDebugLevelRequest_PEER SetDebugLevelRequest_Subsystem = 10
	SetDebugLevelRequest_RPCS SetDebugLevelRequest_Subsystem = 11
	SetDebugLevelRequest_SCRP SetDebugLevelRequest_Subsystem = 12
	SetDebugLevelRequest_SRVR SetDebugLevelRequest_Subsystem = 13
	SetDebugLevelRequest_SYNC SetDebugLevelRequest_Subsystem = 14
	SetDebugLevelRequest_TXMP SetDebugLevelRequest_Subsystem = 15
)

var SetDebugLevelRequest_Subsystem_name = map[int32]string{
	0:  "ALL",
	1:  "ADXR",
	2:  "AMGR",
	3:  "CMGR",
	4:  "BCDB",
	5:  "BTCD",
	6:  "CHAN",
	7:  "DISC",
	8:  "INDX",
	9:  "MINR",
	10: "PEER",
	11: "RPCS",
	12: "SCRP",
	13: "SRVR",
	14: "SYNC",
	15: "TXMP",
}
var SetDebugLevelRequest_Subsystem_value = map[string]int32{
	"ALL":  0,
	"ADXR": 1,
	"AMGR": 2,
	"CMGR": 3,
	"BCDB": 4,
	"BTCD": 5,
	"CHAN": 6,
	"DISC": 7,
	"INDX": 8,
	"MINR": 9,
	"PEER": 10,
	"RPCS": 11,
	"SCRP": 12,
	"SRVR": 13,
	"SYNC": 14,
	"TXMP": 15,
}

func (x SetDebugLevelRequest_Subsystem) String() string {
	return proto.EnumName(SetDebugLevelRequest_Subsystem_name, int32(x))
}
func (SetDebugLevelRequest_Subsystem) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 1}
}

type GetNetworkInfoResponse_BitcoinNet int32

const (
	GetNetworkInfoResponse_MAINNET  GetNetworkInfoResponse_BitcoinNet = 0
	GetNetworkInfoResponse_TESTNET  GetNetworkInfoResponse_BitcoinNet = 1
	GetNetworkInfoResponse_TESTNET3 GetNetworkInfoResponse_BitcoinNet = 2
	GetNetworkInfoResponse_SIMNET   GetNetworkInfoResponse_BitcoinNet = 3
)

var GetNetworkInfoResponse_BitcoinNet_name = map[int32]string{
	0: "MAINNET",
	1: "TESTNET",
	2: "TESTNET3",
	3: "SIMNET",
}
var GetNetworkInfoResponse_BitcoinNet_value = map[string]int32{
	"MAINNET":  0,
	"TESTNET":  1,
	"TESTNET3": 2,
	"SIMNET":   3,
}

func (x GetNetworkInfoResponse_BitcoinNet) String() string {
	return proto.EnumName(GetNetworkInfoResponse_BitcoinNet_name, int32(x))
}
func (GetNetworkInfoResponse_BitcoinNet) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{37, 0}
}

type Block struct {
	Info *BlockInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	// Either one of the two following is provided, depending on the request.
	TransactionHashes [][]byte       `protobuf:"bytes,2,rep,name=transaction_hashes,json=transactionHashes,proto3" json:"transaction_hashes,omitempty"`
	Transactions      []*Transaction `protobuf:"bytes,3,rep,name=transactions" json:"transactions,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Block) GetInfo() *BlockInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Block) GetTransactionHashes() [][]byte {
	if m != nil {
		return m.TransactionHashes
	}
	return nil
}

func (m *Block) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

// TODO(stevenroose) include header bytes?
type BlockInfo struct {
	// Identification.
	Hash   []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Height int32  `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
	// Block header data.
	Version       int32  `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	PreviousBlock []byte `protobuf:"bytes,4,opt,name=previous_block,json=previousBlock,proto3" json:"previous_block,omitempty"`
	MerkleRoot    []byte `protobuf:"bytes,5,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
	Time          int64  `protobuf:"varint,6,opt,name=time" json:"time,omitempty"`
	Bits          uint32 `protobuf:"varint,7,opt,name=bits" json:"bits,omitempty"`
	Nonce         uint32 `protobuf:"varint,8,opt,name=nonce" json:"nonce,omitempty"`
	// Metadata.
	Confirmations int32   `protobuf:"varint,9,opt,name=confirmations" json:"confirmations,omitempty"`
	Difficulty    float64 `protobuf:"fixed64,10,opt,name=difficulty" json:"difficulty,omitempty"`
	NextBlockHash []byte  `protobuf:"bytes,11,opt,name=next_block_hash,json=nextBlockHash,proto3" json:"next_block_hash,omitempty"`
}

func (m *BlockInfo) Reset()                    { *m = BlockInfo{} }
func (m *BlockInfo) String() string            { return proto.CompactTextString(m) }
func (*BlockInfo) ProtoMessage()               {}
func (*BlockInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *BlockInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *BlockInfo) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockInfo) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BlockInfo) GetPreviousBlock() []byte {
	if m != nil {
		return m.PreviousBlock
	}
	return nil
}

func (m *BlockInfo) GetMerkleRoot() []byte {
	if m != nil {
		return m.MerkleRoot
	}
	return nil
}

func (m *BlockInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *BlockInfo) GetBits() uint32 {
	if m != nil {
		return m.Bits
	}
	return 0
}

func (m *BlockInfo) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BlockInfo) GetConfirmations() int32 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *BlockInfo) GetDifficulty() float64 {
	if m != nil {
		return m.Difficulty
	}
	return 0
}

func (m *BlockInfo) GetNextBlockHash() []byte {
	if m != nil {
		return m.NextBlockHash
	}
	return nil
}

// BlockLocator identifies a block.  Provide EITHER hash or height.
type BlockLocator struct {
	// Types that are valid to be assigned to Locator:
	//	*BlockLocator_Hash
	//	*BlockLocator_Height
	Locator isBlockLocator_Locator `protobuf_oneof:"locator"`
}

func (m *BlockLocator) Reset()                    { *m = BlockLocator{} }
func (m *BlockLocator) String() string            { return proto.CompactTextString(m) }
func (*BlockLocator) ProtoMessage()               {}
func (*BlockLocator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isBlockLocator_Locator interface {
	isBlockLocator_Locator()
}

type BlockLocator_Hash struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3,oneof"`
}
type BlockLocator_Height struct {
	Height int32 `protobuf:"varint,2,opt,name=height,oneof"`
}

func (*BlockLocator_Hash) isBlockLocator_Locator()   {}
func (*BlockLocator_Height) isBlockLocator_Locator() {}

func (m *BlockLocator) GetLocator() isBlockLocator_Locator {
	if m != nil {
		return m.Locator
	}
	return nil
}

func (m *BlockLocator) GetHash() []byte {
	if x, ok := m.GetLocator().(*BlockLocator_Hash); ok {
		return x.Hash
	}
	return nil
}

func (m *BlockLocator) GetHeight() int32 {
	if x, ok := m.GetLocator().(*BlockLocator_Height); ok {
		return x.Height
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BlockLocator) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BlockLocator_OneofMarshaler, _BlockLocator_OneofUnmarshaler, _BlockLocator_OneofSizer, []interface{}{
		(*BlockLocator_Hash)(nil),
		(*BlockLocator_Height)(nil),
	}
}

func _BlockLocator_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BlockLocator)
	// locator
	switch x := m.Locator.(type) {
	case *BlockLocator_Hash:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Hash)
	case *BlockLocator_Height:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Height))
	case nil:
	default:
		return fmt.Errorf("BlockLocator.Locator has unexpected type %T", x)
	}
	return nil
}

func _BlockLocator_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BlockLocator)
	switch tag {
	case 1: // locator.hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Locator = &BlockLocator_Hash{x}
		return true, err
	case 2: // locator.height
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Locator = &BlockLocator_Height{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _BlockLocator_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BlockLocator)
	// locator
	switch x := m.Locator.(type) {
	case *BlockLocator_Hash:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Hash)))
		n += len(x.Hash)
	case *BlockLocator_Height:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Height))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NodeInfo struct {
	PeerAddress string              `protobuf:"bytes,1,opt,name=peer_address,json=peerAddress" json:"peer_address,omitempty"`
	Connected   bool                `protobuf:"varint,2,opt,name=connected" json:"connected,omitempty"`
	Addresses   []*NodeInfo_Address `protobuf:"bytes,3,rep,name=addresses" json:"addresses,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *NodeInfo) GetPeerAddress() string {
	if m != nil {
		return m.PeerAddress
	}
	return ""
}

func (m *NodeInfo) GetConnected() bool {
	if m != nil {
		return m.Connected
	}
	return false
}

func (m *NodeInfo) GetAddresses() []*NodeInfo_Address {
	if m != nil {
		return m.Addresses
	}
	return nil
}

type NodeInfo_Address struct {
	Address   string                   `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Connected NodeInfo_ConnectedStatus `protobuf:"varint,2,opt,name=connected,enum=btcrpc.NodeInfo_ConnectedStatus" json:"connected,omitempty"`
}

func (m *NodeInfo_Address) Reset()                    { *m = NodeInfo_Address{} }
func (m *NodeInfo_Address) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo_Address) ProtoMessage()               {}
func (*NodeInfo_Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *NodeInfo_Address) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NodeInfo_Address) GetConnected() NodeInfo_ConnectedStatus {
	if m != nil {
		return m.Connected
	}
	return NodeInfo_DISCONNECTED
}

type Transaction struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// TODO(stevenroose) is it ok to also send encoded all the time? could be
	// performance problem and also make things prettier (encoding returns errors)
	// Besides, we could have Raw endpoints as an alternative.
	Serialized []byte                `protobuf:"bytes,2,opt,name=serialized,proto3" json:"serialized,omitempty"`
	Version    int32                 `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	Inputs     []*Transaction_Input  `protobuf:"bytes,4,rep,name=inputs" json:"inputs,omitempty"`
	Outputs    []*Transaction_Output `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	LockTime   uint32                `protobuf:"varint,6,opt,name=lock_time,json=lockTime" json:"lock_time,omitempty"`
	// Whether the transaction has witness data.
	HasWitness bool `protobuf:"varint,7,opt,name=has_witness,json=hasWitness" json:"has_witness,omitempty"`
	// The withness data hash.
	WitnessHash []byte `protobuf:"bytes,8,opt,name=witness_hash,json=witnessHash,proto3" json:"witness_hash,omitempty"`
	// Metadata
	Time int64 `protobuf:"varint,9,opt,name=time" json:"time,omitempty"`
	// TODO(stevenroose) should we make explicit difference between unconfirmed and unknown?
	Confirmations int32  `protobuf:"varint,10,opt,name=confirmations" json:"confirmations,omitempty"`
	BlockHash     []byte `protobuf:"bytes,11,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Transaction) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Transaction) GetSerialized() []byte {
	if m != nil {
		return m.Serialized
	}
	return nil
}

func (m *Transaction) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Transaction) GetInputs() []*Transaction_Input {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Transaction) GetOutputs() []*Transaction_Output {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Transaction) GetLockTime() uint32 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

func (m *Transaction) GetHasWitness() bool {
	if m != nil {
		return m.HasWitness
	}
	return false
}

func (m *Transaction) GetWitnessHash() []byte {
	if m != nil {
		return m.WitnessHash
	}
	return nil
}

func (m *Transaction) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Transaction) GetConfirmations() int32 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *Transaction) GetBlockHash() []byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

type Transaction_Input struct {
	Coinbase        bool                        `protobuf:"varint,1,opt,name=coinbase" json:"coinbase,omitempty"`
	Outpoint        *Transaction_Input_Outpoint `protobuf:"bytes,2,opt,name=outpoint" json:"outpoint,omitempty"`
	SignatureScript []byte                      `protobuf:"bytes,3,opt,name=signature_script,json=signatureScript,proto3" json:"signature_script,omitempty"`
	// TODO(stevenroose) is decoded script required? tooling should do that I guess
	Sequence    uint32   `protobuf:"varint,4,opt,name=sequence" json:"sequence,omitempty"`
	WitnessData [][]byte `protobuf:"bytes,5,rep,name=witness_data,json=witnessData,proto3" json:"witness_data,omitempty"`
	// TODO(stevenroose) can we provided these always?
	//  (they are provided in the searchrawtransactions call)
	Value int64 `protobuf:"varint,6,opt,name=value" json:"value,omitempty"`
}

func (m *Transaction_Input) Reset()                    { *m = Transaction_Input{} }
func (m *Transaction_Input) String() string            { return proto.CompactTextString(m) }
func (*Transaction_Input) ProtoMessage()               {}
func (*Transaction_Input) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *Transaction_Input) GetCoinbase() bool {
	if m != nil {
		return m.Coinbase
	}
	return false
}

func (m *Transaction_Input) GetOutpoint() *Transaction_Input_Outpoint {
	if m != nil {
		return m.Outpoint
	}
	return nil
}

func (m *Transaction_Input) GetSignatureScript() []byte {
	if m != nil {
		return m.SignatureScript
	}
	return nil
}

func (m *Transaction_Input) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *Transaction_Input) GetWitnessData() [][]byte {
	if m != nil {
		return m.WitnessData
	}
	return nil
}

func (m *Transaction_Input) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Transaction_Input_Outpoint struct {
	Hash  []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *Transaction_Input_Outpoint) Reset()         { *m = Transaction_Input_Outpoint{} }
func (m *Transaction_Input_Outpoint) String() string { return proto.CompactTextString(m) }
func (*Transaction_Input_Outpoint) ProtoMessage()    {}
func (*Transaction_Input_Outpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0, 0}
}

func (m *Transaction_Input_Outpoint) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Transaction_Input_Outpoint) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type Transaction_Output struct {
	Index        uint32 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Value        int64  `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
	PubkeyScript []byte `protobuf:"bytes,3,opt,name=pubkey_script,json=pubkeyScript,proto3" json:"pubkey_script,omitempty"`
}

func (m *Transaction_Output) Reset()                    { *m = Transaction_Output{} }
func (m *Transaction_Output) String() string            { return proto.CompactTextString(m) }
func (*Transaction_Output) ProtoMessage()               {}
func (*Transaction_Output) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

func (m *Transaction_Output) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Transaction_Output) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Transaction_Output) GetPubkeyScript() []byte {
	if m != nil {
		return m.PubkeyScript
	}
	return nil
}

type TransactionFilter struct {
	Addresses []string                      `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
	Outpoints []*Transaction_Input_Outpoint `protobuf:"bytes,2,rep,name=outpoints" json:"outpoints,omitempty"`
}

func (m *TransactionFilter) Reset()                    { *m = TransactionFilter{} }
func (m *TransactionFilter) String() string            { return proto.CompactTextString(m) }
func (*TransactionFilter) ProtoMessage()               {}
func (*TransactionFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TransactionFilter) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *TransactionFilter) GetOutpoints() []*Transaction_Input_Outpoint {
	if m != nil {
		return m.Outpoints
	}
	return nil
}

// TODO(stevenroose) is it worth it to expose this??
type MempoolTransaction struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
	// The time when the transaction was added too the pool.
	AddedTime int64 `protobuf:"varint,2,opt,name=added_time,json=addedTime" json:"added_time,omitempty"`
	// The total fee in satoshi the transaction pays.
	Fee int64 `protobuf:"varint,3,opt,name=fee" json:"fee,omitempty"`
	// The fee in satoshi per byte the transaction pays.
	FeePerByte int64 `protobuf:"varint,4,opt,name=fee_per_byte,json=feePerByte" json:"fee_per_byte,omitempty"`
	// The block height when the transaction was added to the pool.
	Height int32 `protobuf:"varint,5,opt,name=height" json:"height,omitempty"`
	// The priority of the transaction when it was added to the pool.
	StartingPriority float64 `protobuf:"fixed64,6,opt,name=starting_priority,json=startingPriority" json:"starting_priority,omitempty"`
}

func (m *MempoolTransaction) Reset()                    { *m = MempoolTransaction{} }
func (m *MempoolTransaction) String() string            { return proto.CompactTextString(m) }
func (*MempoolTransaction) ProtoMessage()               {}
func (*MempoolTransaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MempoolTransaction) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func (m *MempoolTransaction) GetAddedTime() int64 {
	if m != nil {
		return m.AddedTime
	}
	return 0
}

func (m *MempoolTransaction) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *MempoolTransaction) GetFeePerByte() int64 {
	if m != nil {
		return m.FeePerByte
	}
	return 0
}

func (m *MempoolTransaction) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MempoolTransaction) GetStartingPriority() float64 {
	if m != nil {
		return m.StartingPriority
	}
	return 0
}

type UnspentOutput struct {
	Outpoint *Transaction_Input_Outpoint `protobuf:"bytes,1,opt,name=outpoint" json:"outpoint,omitempty"`
	// TODO(stevenroose) should we move away from scriptsig and scriptpubkey to
	// just output script and input script?
	PubkeyScript []byte `protobuf:"bytes,2,opt,name=pubkey_script,json=pubkeyScript,proto3" json:"pubkey_script,omitempty"`
	Value        int64  `protobuf:"varint,3,opt,name=value" json:"value,omitempty"`
	IsCoinbase   bool   `protobuf:"varint,4,opt,name=is_coinbase,json=isCoinbase" json:"is_coinbase,omitempty"`
	BlockHeight  int32  `protobuf:"varint,5,opt,name=block_height,json=blockHeight" json:"block_height,omitempty"`
}

func (m *UnspentOutput) Reset()                    { *m = UnspentOutput{} }
func (m *UnspentOutput) String() string            { return proto.CompactTextString(m) }
func (*UnspentOutput) ProtoMessage()               {}
func (*UnspentOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UnspentOutput) GetOutpoint() *Transaction_Input_Outpoint {
	if m != nil {
		return m.Outpoint
	}
	return nil
}

func (m *UnspentOutput) GetPubkeyScript() []byte {
	if m != nil {
		return m.PubkeyScript
	}
	return nil
}

func (m *UnspentOutput) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *UnspentOutput) GetIsCoinbase() bool {
	if m != nil {
		return m.IsCoinbase
	}
	return false
}

func (m *UnspentOutput) GetBlockHeight() int32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type BlockNotification struct {
	Type  BlockNotification_Type `protobuf:"varint,1,opt,name=type,enum=btcrpc.BlockNotification_Type" json:"type,omitempty"`
	Block *Block                 `protobuf:"bytes,2,opt,name=block" json:"block,omitempty"`
}

func (m *BlockNotification) Reset()                    { *m = BlockNotification{} }
func (m *BlockNotification) String() string            { return proto.CompactTextString(m) }
func (*BlockNotification) ProtoMessage()               {}
func (*BlockNotification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BlockNotification) GetType() BlockNotification_Type {
	if m != nil {
		return m.Type
	}
	return BlockNotification_CONNECTED
}

func (m *BlockNotification) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

type TransactionNotification struct {
	Type TransactionNotification_Type `protobuf:"varint,1,opt,name=type,enum=btcrpc.TransactionNotification_Type" json:"type,omitempty"`
	// Types that are valid to be assigned to Transaction:
	//	*TransactionNotification_ConfirmedTransaction
	//	*TransactionNotification_AcceptedTransaction
	Transaction isTransactionNotification_Transaction `protobuf_oneof:"transaction"`
}

func (m *TransactionNotification) Reset()                    { *m = TransactionNotification{} }
func (m *TransactionNotification) String() string            { return proto.CompactTextString(m) }
func (*TransactionNotification) ProtoMessage()               {}
func (*TransactionNotification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isTransactionNotification_Transaction interface {
	isTransactionNotification_Transaction()
}

type TransactionNotification_ConfirmedTransaction struct {
	ConfirmedTransaction *Transaction `protobuf:"bytes,2,opt,name=confirmed_transaction,json=confirmedTransaction,oneof"`
}
type TransactionNotification_AcceptedTransaction struct {
	AcceptedTransaction *MempoolTransaction `protobuf:"bytes,3,opt,name=accepted_transaction,json=acceptedTransaction,oneof"`
}

func (*TransactionNotification_ConfirmedTransaction) isTransactionNotification_Transaction() {}
func (*TransactionNotification_AcceptedTransaction) isTransactionNotification_Transaction()  {}

func (m *TransactionNotification) GetTransaction() isTransactionNotification_Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func (m *TransactionNotification) GetType() TransactionNotification_Type {
	if m != nil {
		return m.Type
	}
	return TransactionNotification_ACCEPTED
}

func (m *TransactionNotification) GetConfirmedTransaction() *Transaction {
	if x, ok := m.GetTransaction().(*TransactionNotification_ConfirmedTransaction); ok {
		return x.ConfirmedTransaction
	}
	return nil
}

func (m *TransactionNotification) GetAcceptedTransaction() *MempoolTransaction {
	if x, ok := m.GetTransaction().(*TransactionNotification_AcceptedTransaction); ok {
		return x.AcceptedTransaction
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TransactionNotification) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TransactionNotification_OneofMarshaler, _TransactionNotification_OneofUnmarshaler, _TransactionNotification_OneofSizer, []interface{}{
		(*TransactionNotification_ConfirmedTransaction)(nil),
		(*TransactionNotification_AcceptedTransaction)(nil),
	}
}

func _TransactionNotification_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TransactionNotification)
	// transaction
	switch x := m.Transaction.(type) {
	case *TransactionNotification_ConfirmedTransaction:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfirmedTransaction); err != nil {
			return err
		}
	case *TransactionNotification_AcceptedTransaction:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AcceptedTransaction); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TransactionNotification.Transaction has unexpected type %T", x)
	}
	return nil
}

func _TransactionNotification_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TransactionNotification)
	switch tag {
	case 2: // transaction.confirmed_transaction
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Transaction)
		err := b.DecodeMessage(msg)
		m.Transaction = &TransactionNotification_ConfirmedTransaction{msg}
		return true, err
	case 3: // transaction.accepted_transaction
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MempoolTransaction)
		err := b.DecodeMessage(msg)
		m.Transaction = &TransactionNotification_AcceptedTransaction{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TransactionNotification_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TransactionNotification)
	// transaction
	switch x := m.Transaction.(type) {
	case *TransactionNotification_ConfirmedTransaction:
		s := proto.Size(x.ConfirmedTransaction)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TransactionNotification_AcceptedTransaction:
		s := proto.Size(x.AcceptedTransaction)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ConnectPeerRequest struct {
	PeerAddress string `protobuf:"bytes,1,opt,name=peer_address,json=peerAddress" json:"peer_address,omitempty"`
	Permanent   bool   `protobuf:"varint,2,opt,name=permanent" json:"permanent,omitempty"`
}

func (m *ConnectPeerRequest) Reset()                    { *m = ConnectPeerRequest{} }
func (m *ConnectPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectPeerRequest) ProtoMessage()               {}
func (*ConnectPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ConnectPeerRequest) GetPeerAddress() string {
	if m != nil {
		return m.PeerAddress
	}
	return ""
}

func (m *ConnectPeerRequest) GetPermanent() bool {
	if m != nil {
		return m.Permanent
	}
	return false
}

type ConnectPeerResponse struct {
}

func (m *ConnectPeerResponse) Reset()                    { *m = ConnectPeerResponse{} }
func (m *ConnectPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectPeerResponse) ProtoMessage()               {}
func (*ConnectPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type SetDebugLevelRequest struct {
	Level     SetDebugLevelRequest_DebugLevel `protobuf:"varint,1,opt,name=level,enum=btcrpc.SetDebugLevelRequest_DebugLevel" json:"level,omitempty"`
	Subsystem SetDebugLevelRequest_Subsystem  `protobuf:"varint,2,opt,name=subsystem,enum=btcrpc.SetDebugLevelRequest_Subsystem" json:"subsystem,omitempty"`
}

func (m *SetDebugLevelRequest) Reset()                    { *m = SetDebugLevelRequest{} }
func (m *SetDebugLevelRequest) String() string            { return proto.CompactTextString(m) }
func (*SetDebugLevelRequest) ProtoMessage()               {}
func (*SetDebugLevelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SetDebugLevelRequest) GetLevel() SetDebugLevelRequest_DebugLevel {
	if m != nil {
		return m.Level
	}
	return SetDebugLevelRequest_TRACE
}

func (m *SetDebugLevelRequest) GetSubsystem() SetDebugLevelRequest_Subsystem {
	if m != nil {
		return m.Subsystem
	}
	return SetDebugLevelRequest_ALL
}

type SetDebugLevelResponse struct {
}

func (m *SetDebugLevelResponse) Reset()                    { *m = SetDebugLevelResponse{} }
func (m *SetDebugLevelResponse) String() string            { return proto.CompactTextString(m) }
func (*SetDebugLevelResponse) ProtoMessage()               {}
func (*SetDebugLevelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type DisconnectPeerRequest struct {
	// Types that are valid to be assigned to Peer:
	//	*DisconnectPeerRequest_PeerAddress
	//	*DisconnectPeerRequest_PeerId
	Peer      isDisconnectPeerRequest_Peer `protobuf_oneof:"peer"`
	Permanent bool                         `protobuf:"varint,3,opt,name=permanent" json:"permanent,omitempty"`
}

func (m *DisconnectPeerRequest) Reset()                    { *m = DisconnectPeerRequest{} }
func (m *DisconnectPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*DisconnectPeerRequest) ProtoMessage()               {}
func (*DisconnectPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type isDisconnectPeerRequest_Peer interface {
	isDisconnectPeerRequest_Peer()
}

type DisconnectPeerRequest_PeerAddress struct {
	PeerAddress string `protobuf:"bytes,1,opt,name=peer_address,json=peerAddress,oneof"`
}
type DisconnectPeerRequest_PeerId struct {
	PeerId uint32 `protobuf:"varint,2,opt,name=peer_id,json=peerId,oneof"`
}

func (*DisconnectPeerRequest_PeerAddress) isDisconnectPeerRequest_Peer() {}
func (*DisconnectPeerRequest_PeerId) isDisconnectPeerRequest_Peer()      {}

func (m *DisconnectPeerRequest) GetPeer() isDisconnectPeerRequest_Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *DisconnectPeerRequest) GetPeerAddress() string {
	if x, ok := m.GetPeer().(*DisconnectPeerRequest_PeerAddress); ok {
		return x.PeerAddress
	}
	return ""
}

func (m *DisconnectPeerRequest) GetPeerId() uint32 {
	if x, ok := m.GetPeer().(*DisconnectPeerRequest_PeerId); ok {
		return x.PeerId
	}
	return 0
}

func (m *DisconnectPeerRequest) GetPermanent() bool {
	if m != nil {
		return m.Permanent
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DisconnectPeerRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DisconnectPeerRequest_OneofMarshaler, _DisconnectPeerRequest_OneofUnmarshaler, _DisconnectPeerRequest_OneofSizer, []interface{}{
		(*DisconnectPeerRequest_PeerAddress)(nil),
		(*DisconnectPeerRequest_PeerId)(nil),
	}
}

func _DisconnectPeerRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DisconnectPeerRequest)
	// peer
	switch x := m.Peer.(type) {
	case *DisconnectPeerRequest_PeerAddress:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.PeerAddress)
	case *DisconnectPeerRequest_PeerId:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.PeerId))
	case nil:
	default:
		return fmt.Errorf("DisconnectPeerRequest.Peer has unexpected type %T", x)
	}
	return nil
}

func _DisconnectPeerRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DisconnectPeerRequest)
	switch tag {
	case 1: // peer.peer_address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Peer = &DisconnectPeerRequest_PeerAddress{x}
		return true, err
	case 2: // peer.peer_id
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Peer = &DisconnectPeerRequest_PeerId{uint32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _DisconnectPeerRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DisconnectPeerRequest)
	// peer
	switch x := m.Peer.(type) {
	case *DisconnectPeerRequest_PeerAddress:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PeerAddress)))
		n += len(x.PeerAddress)
	case *DisconnectPeerRequest_PeerId:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.PeerId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DisconnectPeerResponse struct {
}

func (m *DisconnectPeerResponse) Reset()                    { *m = DisconnectPeerResponse{} }
func (m *DisconnectPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*DisconnectPeerResponse) ProtoMessage()               {}
func (*DisconnectPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type GenerateBlocksRequest struct {
	NbBlocks      uint32 `protobuf:"varint,1,opt,name=nb_blocks,json=nbBlocks" json:"nb_blocks,omitempty"`
	PayoutAddress string `protobuf:"bytes,2,opt,name=payout_address,json=payoutAddress" json:"payout_address,omitempty"`
}

func (m *GenerateBlocksRequest) Reset()                    { *m = GenerateBlocksRequest{} }
func (m *GenerateBlocksRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateBlocksRequest) ProtoMessage()               {}
func (*GenerateBlocksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GenerateBlocksRequest) GetNbBlocks() uint32 {
	if m != nil {
		return m.NbBlocks
	}
	return 0
}

func (m *GenerateBlocksRequest) GetPayoutAddress() string {
	if m != nil {
		return m.PayoutAddress
	}
	return ""
}

type GenerateBlocksResponse struct {
	BlockHashes [][]byte `protobuf:"bytes,1,rep,name=block_hashes,json=blockHashes,proto3" json:"block_hashes,omitempty"`
}

func (m *GenerateBlocksResponse) Reset()                    { *m = GenerateBlocksResponse{} }
func (m *GenerateBlocksResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateBlocksResponse) ProtoMessage()               {}
func (*GenerateBlocksResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *GenerateBlocksResponse) GetBlockHashes() [][]byte {
	if m != nil {
		return m.BlockHashes
	}
	return nil
}

type GetBestBlockInfoRequest struct {
}

func (m *GetBestBlockInfoRequest) Reset()                    { *m = GetBestBlockInfoRequest{} }
func (m *GetBestBlockInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBestBlockInfoRequest) ProtoMessage()               {}
func (*GetBestBlockInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

type GetBestBlockInfoResponse struct {
	Info *BlockInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetBestBlockInfoResponse) Reset()                    { *m = GetBestBlockInfoResponse{} }
func (m *GetBestBlockInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBestBlockInfoResponse) ProtoMessage()               {}
func (*GetBestBlockInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GetBestBlockInfoResponse) GetInfo() *BlockInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type GetBlockRequest struct {
	Locator *BlockLocator `protobuf:"bytes,1,opt,name=locator" json:"locator,omitempty"`
	// Provide full transaction info instead of only the hashes.
	FullTransactions bool `protobuf:"varint,2,opt,name=full_transactions,json=fullTransactions" json:"full_transactions,omitempty"`
}

func (m *GetBlockRequest) Reset()                    { *m = GetBlockRequest{} }
func (m *GetBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockRequest) ProtoMessage()               {}
func (*GetBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetBlockRequest) GetLocator() *BlockLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

func (m *GetBlockRequest) GetFullTransactions() bool {
	if m != nil {
		return m.FullTransactions
	}
	return false
}

type GetBlockResponse struct {
	Block *Block `protobuf:"bytes,1,opt,name=block" json:"block,omitempty"`
}

func (m *GetBlockResponse) Reset()                    { *m = GetBlockResponse{} }
func (m *GetBlockResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockResponse) ProtoMessage()               {}
func (*GetBlockResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetBlockResponse) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

type GetBlockCountRequest struct {
}

func (m *GetBlockCountRequest) Reset()                    { *m = GetBlockCountRequest{} }
func (m *GetBlockCountRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockCountRequest) ProtoMessage()               {}
func (*GetBlockCountRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

type GetBlockCountResponse struct {
	BlockCount uint32 `protobuf:"varint,1,opt,name=block_count,json=blockCount" json:"block_count,omitempty"`
}

func (m *GetBlockCountResponse) Reset()                    { *m = GetBlockCountResponse{} }
func (m *GetBlockCountResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockCountResponse) ProtoMessage()               {}
func (*GetBlockCountResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *GetBlockCountResponse) GetBlockCount() uint32 {
	if m != nil {
		return m.BlockCount
	}
	return 0
}

type GetBlockInfoRequest struct {
	Locator *BlockLocator `protobuf:"bytes,1,opt,name=locator" json:"locator,omitempty"`
}

func (m *GetBlockInfoRequest) Reset()                    { *m = GetBlockInfoRequest{} }
func (m *GetBlockInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockInfoRequest) ProtoMessage()               {}
func (*GetBlockInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *GetBlockInfoRequest) GetLocator() *BlockLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

type GetBlockInfoResponse struct {
	Info *BlockInfo `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetBlockInfoResponse) Reset()                    { *m = GetBlockInfoResponse{} }
func (m *GetBlockInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockInfoResponse) ProtoMessage()               {}
func (*GetBlockInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GetBlockInfoResponse) GetInfo() *BlockInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type GetGenerateInfoRequest struct {
}

func (m *GetGenerateInfoRequest) Reset()                    { *m = GetGenerateInfoRequest{} }
func (m *GetGenerateInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGenerateInfoRequest) ProtoMessage()               {}
func (*GetGenerateInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

type GetGenerateInfoResponse struct {
	Generate             bool    `protobuf:"varint,1,opt,name=generate" json:"generate,omitempty"`
	NbWorkers            int32   `protobuf:"varint,2,opt,name=nb_workers,json=nbWorkers" json:"nb_workers,omitempty"`
	Hashrate             uint64  `protobuf:"varint,3,opt,name=hashrate" json:"hashrate,omitempty"`
	Difficulty           float64 `protobuf:"fixed64,4,opt,name=difficulty" json:"difficulty,omitempty"`
	NbPooledTransactions uint32  `protobuf:"varint,5,opt,name=nb_pooled_transactions,json=nbPooledTransactions" json:"nb_pooled_transactions,omitempty"`
}

func (m *GetGenerateInfoResponse) Reset()                    { *m = GetGenerateInfoResponse{} }
func (m *GetGenerateInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetGenerateInfoResponse) ProtoMessage()               {}
func (*GetGenerateInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *GetGenerateInfoResponse) GetGenerate() bool {
	if m != nil {
		return m.Generate
	}
	return false
}

func (m *GetGenerateInfoResponse) GetNbWorkers() int32 {
	if m != nil {
		return m.NbWorkers
	}
	return 0
}

func (m *GetGenerateInfoResponse) GetHashrate() uint64 {
	if m != nil {
		return m.Hashrate
	}
	return 0
}

func (m *GetGenerateInfoResponse) GetDifficulty() float64 {
	if m != nil {
		return m.Difficulty
	}
	return 0
}

func (m *GetGenerateInfoResponse) GetNbPooledTransactions() uint32 {
	if m != nil {
		return m.NbPooledTransactions
	}
	return 0
}

type GetMempoolRequest struct {
	// Provide full transaction info instead of only the hashes.
	FullTransactions bool `protobuf:"varint,1,opt,name=full_transactions,json=fullTransactions" json:"full_transactions,omitempty"`
}

func (m *GetMempoolRequest) Reset()                    { *m = GetMempoolRequest{} }
func (m *GetMempoolRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMempoolRequest) ProtoMessage()               {}
func (*GetMempoolRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *GetMempoolRequest) GetFullTransactions() bool {
	if m != nil {
		return m.FullTransactions
	}
	return false
}

type GetMempoolResponse struct {
	// Either one of the two following is provided, depending on the request.
	TransactionHashes [][]byte              `protobuf:"bytes,1,rep,name=transaction_hashes,json=transactionHashes,proto3" json:"transaction_hashes,omitempty"`
	Transactions      []*MempoolTransaction `protobuf:"bytes,2,rep,name=transactions" json:"transactions,omitempty"`
}

func (m *GetMempoolResponse) Reset()                    { *m = GetMempoolResponse{} }
func (m *GetMempoolResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMempoolResponse) ProtoMessage()               {}
func (*GetMempoolResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *GetMempoolResponse) GetTransactionHashes() [][]byte {
	if m != nil {
		return m.TransactionHashes
	}
	return nil
}

func (m *GetMempoolResponse) GetTransactions() []*MempoolTransaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type GetMempoolInfoRequest struct {
}

func (m *GetMempoolInfoRequest) Reset()                    { *m = GetMempoolInfoRequest{} }
func (m *GetMempoolInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMempoolInfoRequest) ProtoMessage()               {}
func (*GetMempoolInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

type GetMempoolInfoResponse struct {
	NbTransactions uint32 `protobuf:"varint,1,opt,name=nb_transactions,json=nbTransactions" json:"nb_transactions,omitempty"`
	NbBytes        uint64 `protobuf:"varint,2,opt,name=nb_bytes,json=nbBytes" json:"nb_bytes,omitempty"`
}

func (m *GetMempoolInfoResponse) Reset()                    { *m = GetMempoolInfoResponse{} }
func (m *GetMempoolInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMempoolInfoResponse) ProtoMessage()               {}
func (*GetMempoolInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *GetMempoolInfoResponse) GetNbTransactions() uint32 {
	if m != nil {
		return m.NbTransactions
	}
	return 0
}

func (m *GetMempoolInfoResponse) GetNbBytes() uint64 {
	if m != nil {
		return m.NbBytes
	}
	return 0
}

type GetMiningInfoRequest struct {
}

func (m *GetMiningInfoRequest) Reset()                    { *m = GetMiningInfoRequest{} }
func (m *GetMiningInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMiningInfoRequest) ProtoMessage()               {}
func (*GetMiningInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

type GetMiningInfoResponse struct {
	NetworkHashrate            uint64  `protobuf:"varint,1,opt,name=network_hashrate,json=networkHashrate" json:"network_hashrate,omitempty"`
	CurrentBlockHeight         int32   `protobuf:"varint,2,opt,name=current_block_height,json=currentBlockHeight" json:"current_block_height,omitempty"`
	CurrentBlockSize           uint64  `protobuf:"varint,3,opt,name=current_block_size,json=currentBlockSize" json:"current_block_size,omitempty"`
	CurrentBlockWeight         uint64  `protobuf:"varint,4,opt,name=current_block_weight,json=currentBlockWeight" json:"current_block_weight,omitempty"`
	CurrentBlockNbTransactions uint32  `protobuf:"varint,5,opt,name=current_block_nb_transactions,json=currentBlockNbTransactions" json:"current_block_nb_transactions,omitempty"`
	Difficulty                 float64 `protobuf:"fixed64,6,opt,name=difficulty" json:"difficulty,omitempty"`
	Errors                     string  `protobuf:"bytes,7,opt,name=errors" json:"errors,omitempty"`
}

func (m *GetMiningInfoResponse) Reset()                    { *m = GetMiningInfoResponse{} }
func (m *GetMiningInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMiningInfoResponse) ProtoMessage()               {}
func (*GetMiningInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *GetMiningInfoResponse) GetNetworkHashrate() uint64 {
	if m != nil {
		return m.NetworkHashrate
	}
	return 0
}

func (m *GetMiningInfoResponse) GetCurrentBlockHeight() int32 {
	if m != nil {
		return m.CurrentBlockHeight
	}
	return 0
}

func (m *GetMiningInfoResponse) GetCurrentBlockSize() uint64 {
	if m != nil {
		return m.CurrentBlockSize
	}
	return 0
}

func (m *GetMiningInfoResponse) GetCurrentBlockWeight() uint64 {
	if m != nil {
		return m.CurrentBlockWeight
	}
	return 0
}

func (m *GetMiningInfoResponse) GetCurrentBlockNbTransactions() uint32 {
	if m != nil {
		return m.CurrentBlockNbTransactions
	}
	return 0
}

func (m *GetMiningInfoResponse) GetDifficulty() float64 {
	if m != nil {
		return m.Difficulty
	}
	return 0
}

func (m *GetMiningInfoResponse) GetErrors() string {
	if m != nil {
		return m.Errors
	}
	return ""
}

type GetNetworkHashRateRequest struct {
	// The height of the block at which to calculate the hashrate.
	// The default is the current best height.
	EndHeight int32 `protobuf:"varint,1,opt,name=end_height,json=endHeight" json:"end_height,omitempty"`
	// The amount of blocks in the period to use for the calculation.
	// Use -1 to use the number of blocks since the last difficulty change.
	// The default is 120.
	NbBlocks int32 `protobuf:"varint,2,opt,name=nb_blocks,json=nbBlocks" json:"nb_blocks,omitempty"`
}

func (m *GetNetworkHashRateRequest) Reset()                    { *m = GetNetworkHashRateRequest{} }
func (m *GetNetworkHashRateRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNetworkHashRateRequest) ProtoMessage()               {}
func (*GetNetworkHashRateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *GetNetworkHashRateRequest) GetEndHeight() int32 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *GetNetworkHashRateRequest) GetNbBlocks() int32 {
	if m != nil {
		return m.NbBlocks
	}
	return 0
}

type GetNetworkHashRateResponse struct {
	Hashrate uint64 `protobuf:"varint,1,opt,name=hashrate" json:"hashrate,omitempty"`
}

func (m *GetNetworkHashRateResponse) Reset()                    { *m = GetNetworkHashRateResponse{} }
func (m *GetNetworkHashRateResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNetworkHashRateResponse) ProtoMessage()               {}
func (*GetNetworkHashRateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *GetNetworkHashRateResponse) GetHashrate() uint64 {
	if m != nil {
		return m.Hashrate
	}
	return 0
}

type GetNetworkInfoRequest struct {
}

func (m *GetNetworkInfoRequest) Reset()                    { *m = GetNetworkInfoRequest{} }
func (m *GetNetworkInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNetworkInfoRequest) ProtoMessage()               {}
func (*GetNetworkInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

type GetNetworkInfoResponse struct {
	BitcoinNet GetNetworkInfoResponse_BitcoinNet `protobuf:"varint,1,opt,name=bitcoin_net,json=bitcoinNet,enum=btcrpc.GetNetworkInfoResponse_BitcoinNet" json:"bitcoin_net,omitempty"`
	BestHeight int32                             `protobuf:"varint,2,opt,name=best_height,json=bestHeight" json:"best_height,omitempty"`
	TimeOffset int64                             `protobuf:"varint,3,opt,name=time_offset,json=timeOffset" json:"time_offset,omitempty"`
	Difficulty float64                           `protobuf:"fixed64,4,opt,name=difficulty" json:"difficulty,omitempty"`
	Hashrate   uint64                            `protobuf:"varint,5,opt,name=hashrate" json:"hashrate,omitempty"`
	RelayFee   float64                           `protobuf:"fixed64,6,opt,name=relay_fee,json=relayFee" json:"relay_fee,omitempty"`
}

func (m *GetNetworkInfoResponse) Reset()                    { *m = GetNetworkInfoResponse{} }
func (m *GetNetworkInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNetworkInfoResponse) ProtoMessage()               {}
func (*GetNetworkInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *GetNetworkInfoResponse) GetBitcoinNet() GetNetworkInfoResponse_BitcoinNet {
	if m != nil {
		return m.BitcoinNet
	}
	return GetNetworkInfoResponse_MAINNET
}

func (m *GetNetworkInfoResponse) GetBestHeight() int32 {
	if m != nil {
		return m.BestHeight
	}
	return 0
}

func (m *GetNetworkInfoResponse) GetTimeOffset() int64 {
	if m != nil {
		return m.TimeOffset
	}
	return 0
}

func (m *GetNetworkInfoResponse) GetDifficulty() float64 {
	if m != nil {
		return m.Difficulty
	}
	return 0
}

func (m *GetNetworkInfoResponse) GetHashrate() uint64 {
	if m != nil {
		return m.Hashrate
	}
	return 0
}

func (m *GetNetworkInfoResponse) GetRelayFee() float64 {
	if m != nil {
		return m.RelayFee
	}
	return 0
}

type GetPeersRequest struct {
	Permanent bool `protobuf:"varint,1,opt,name=permanent" json:"permanent,omitempty"`
}

func (m *GetPeersRequest) Reset()                    { *m = GetPeersRequest{} }
func (m *GetPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPeersRequest) ProtoMessage()               {}
func (*GetPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *GetPeersRequest) GetPermanent() bool {
	if m != nil {
		return m.Permanent
	}
	return false
}

type GetPeersResponse struct {
	Peers []*GetPeersResponse_PeerInfo `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *GetPeersResponse) Reset()                    { *m = GetPeersResponse{} }
func (m *GetPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*GetPeersResponse) ProtoMessage()               {}
func (*GetPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *GetPeersResponse) GetPeers() []*GetPeersResponse_PeerInfo {
	if m != nil {
		return m.Peers
	}
	return nil
}

type GetPeersResponse_PeerInfo struct {
	Id           int32  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Address      string `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	LocalAddress string `protobuf:"bytes,3,opt,name=local_address,json=localAddress" json:"local_address,omitempty"`
	Version      uint32 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	UserAgent    string `protobuf:"bytes,5,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	// TODO(stevenroose) this is string in current API, why?
	Services       string `protobuf:"bytes,6,opt,name=services" json:"services,omitempty"`
	Inbound        bool   `protobuf:"varint,7,opt,name=inbound" json:"inbound,omitempty"`
	SyncNode       bool   `protobuf:"varint,8,opt,name=sync_node,json=syncNode" json:"sync_node,omitempty"`
	RelayTxs       bool   `protobuf:"varint,9,opt,name=relay_txs,json=relayTxs" json:"relay_txs,omitempty"`
	LastSendTime   int64  `protobuf:"varint,10,opt,name=last_send_time,json=lastSendTime" json:"last_send_time,omitempty"`
	LastRecvTime   int64  `protobuf:"varint,11,opt,name=last_recv_time,json=lastRecvTime" json:"last_recv_time,omitempty"`
	ConnectionTime int64  `protobuf:"varint,12,opt,name=connection_time,json=connectionTime" json:"connection_time,omitempty"`
	BytesSent      uint64 `protobuf:"varint,13,opt,name=bytes_sent,json=bytesSent" json:"bytes_sent,omitempty"`
	BytesReceived  uint64 `protobuf:"varint,14,opt,name=bytes_received,json=bytesReceived" json:"bytes_received,omitempty"`
	TimeOffset     int64  `protobuf:"varint,15,opt,name=time_offset,json=timeOffset" json:"time_offset,omitempty"`
	LastPingTime   int64  `protobuf:"varint,16,opt,name=last_ping_time,json=lastPingTime" json:"last_ping_time,omitempty"`
	LastPingMicros int64  `protobuf:"varint,17,opt,name=last_ping_micros,json=lastPingMicros" json:"last_ping_micros,omitempty"`
	StartingHeight int32  `protobuf:"varint,18,opt,name=starting_height,json=startingHeight" json:"starting_height,omitempty"`
	CurrentHeight  int32  `protobuf:"varint,19,opt,name=current_height,json=currentHeight" json:"current_height,omitempty"`
	BanScore       int32  `protobuf:"varint,20,opt,name=ban_score,json=banScore" json:"ban_score,omitempty"`
	FeeFilter      int64  `protobuf:"varint,21,opt,name=fee_filter,json=feeFilter" json:"fee_filter,omitempty"`
}

func (m *GetPeersResponse_PeerInfo) Reset()                    { *m = GetPeersResponse_PeerInfo{} }
func (m *GetPeersResponse_PeerInfo) String() string            { return proto.CompactTextString(m) }
func (*GetPeersResponse_PeerInfo) ProtoMessage()               {}
func (*GetPeersResponse_PeerInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39, 0} }

func (m *GetPeersResponse_PeerInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetPeersResponse_PeerInfo) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

func (m *GetPeersResponse_PeerInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *GetPeersResponse_PeerInfo) GetServices() string {
	if m != nil {
		return m.Services
	}
	return ""
}

func (m *GetPeersResponse_PeerInfo) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *GetPeersResponse_PeerInfo) GetSyncNode() bool {
	if m != nil {
		return m.SyncNode
	}
	return false
}

func (m *GetPeersResponse_PeerInfo) GetRelayTxs() bool {
	if m != nil {
		return m.RelayTxs
	}
	return false
}

func (m *GetPeersResponse_PeerInfo) GetLastSendTime() int64 {
	if m != nil {
		return m.LastSendTime
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetLastRecvTime() int64 {
	if m != nil {
		return m.LastRecvTime
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetConnectionTime() int64 {
	if m != nil {
		return m.ConnectionTime
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetBytesReceived() uint64 {
	if m != nil {
		return m.BytesReceived
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetTimeOffset() int64 {
	if m != nil {
		return m.TimeOffset
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetLastPingTime() int64 {
	if m != nil {
		return m.LastPingTime
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetLastPingMicros() int64 {
	if m != nil {
		return m.LastPingMicros
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetStartingHeight() int32 {
	if m != nil {
		return m.StartingHeight
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetCurrentHeight() int32 {
	if m != nil {
		return m.CurrentHeight
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetBanScore() int32 {
	if m != nil {
		return m.BanScore
	}
	return 0
}

func (m *GetPeersResponse_PeerInfo) GetFeeFilter() int64 {
	if m != nil {
		return m.FeeFilter
	}
	return 0
}

type GetRawBlockRequest struct {
	Locator *BlockLocator `protobuf:"bytes,1,opt,name=locator" json:"locator,omitempty"`
}

func (m *GetRawBlockRequest) Reset()                    { *m = GetRawBlockRequest{} }
func (m *GetRawBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRawBlockRequest) ProtoMessage()               {}
func (*GetRawBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *GetRawBlockRequest) GetLocator() *BlockLocator {
	if m != nil {
		return m.Locator
	}
	return nil
}

type GetRawBlockResponse struct {
	Block []byte `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *GetRawBlockResponse) Reset()                    { *m = GetRawBlockResponse{} }
func (m *GetRawBlockResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRawBlockResponse) ProtoMessage()               {}
func (*GetRawBlockResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *GetRawBlockResponse) GetBlock() []byte {
	if m != nil {
		return m.Block
	}
	return nil
}

type GetRawMempoolRequest struct {
}

func (m *GetRawMempoolRequest) Reset()                    { *m = GetRawMempoolRequest{} }
func (m *GetRawMempoolRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRawMempoolRequest) ProtoMessage()               {}
func (*GetRawMempoolRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

type GetRawMempoolResponse struct {
	Transactions [][]byte `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
}

func (m *GetRawMempoolResponse) Reset()                    { *m = GetRawMempoolResponse{} }
func (m *GetRawMempoolResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRawMempoolResponse) ProtoMessage()               {}
func (*GetRawMempoolResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *GetRawMempoolResponse) GetTransactions() [][]byte {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type GetRawTransactionRequest struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *GetRawTransactionRequest) Reset()                    { *m = GetRawTransactionRequest{} }
func (m *GetRawTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRawTransactionRequest) ProtoMessage()               {}
func (*GetRawTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *GetRawTransactionRequest) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type GetRawTransactionResponse struct {
	Transaction []byte `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (m *GetRawTransactionResponse) Reset()                    { *m = GetRawTransactionResponse{} }
func (m *GetRawTransactionResponse) String() string            { return proto.CompactTextString(m) }
func (*GetRawTransactionResponse) ProtoMessage()               {}
func (*GetRawTransactionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *GetRawTransactionResponse) GetTransaction() []byte {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type GetSystemInfoRequest struct {
}

func (m *GetSystemInfoRequest) Reset()                    { *m = GetSystemInfoRequest{} }
func (m *GetSystemInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSystemInfoRequest) ProtoMessage()               {}
func (*GetSystemInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

type GetSystemInfoResponse struct {
	Version            uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	ProtocolVersion    uint32 `protobuf:"varint,2,opt,name=protocol_version,json=protocolVersion" json:"protocol_version,omitempty"`
	CurrentTimeMillis  int64  `protobuf:"varint,3,opt,name=current_time_millis,json=currentTimeMillis" json:"current_time_millis,omitempty"`
	RunningTime        int64  `protobuf:"varint,4,opt,name=running_time,json=runningTime" json:"running_time,omitempty"`
	TotalBytesReceived uint64 `protobuf:"varint,5,opt,name=total_bytes_received,json=totalBytesReceived" json:"total_bytes_received,omitempty"`
	TotalBytesSent     uint64 `protobuf:"varint,6,opt,name=total_bytes_sent,json=totalBytesSent" json:"total_bytes_sent,omitempty"`
	Proxy              string `protobuf:"bytes,7,opt,name=proxy" json:"proxy,omitempty"`
	NbConnections      uint32 `protobuf:"varint,8,opt,name=nb_connections,json=nbConnections" json:"nb_connections,omitempty"`
}

func (m *GetSystemInfoResponse) Reset()                    { *m = GetSystemInfoResponse{} }
func (m *GetSystemInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSystemInfoResponse) ProtoMessage()               {}
func (*GetSystemInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *GetSystemInfoResponse) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetSystemInfoResponse) GetProtocolVersion() uint32 {
	if m != nil {
		return m.ProtocolVersion
	}
	return 0
}

func (m *GetSystemInfoResponse) GetCurrentTimeMillis() int64 {
	if m != nil {
		return m.CurrentTimeMillis
	}
	return 0
}

func (m *GetSystemInfoResponse) GetRunningTime() int64 {
	if m != nil {
		return m.RunningTime
	}
	return 0
}

func (m *GetSystemInfoResponse) GetTotalBytesReceived() uint64 {
	if m != nil {
		return m.TotalBytesReceived
	}
	return 0
}

func (m *GetSystemInfoResponse) GetTotalBytesSent() uint64 {
	if m != nil {
		return m.TotalBytesSent
	}
	return 0
}

func (m *GetSystemInfoResponse) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *GetSystemInfoResponse) GetNbConnections() uint32 {
	if m != nil {
		return m.NbConnections
	}
	return 0
}

type GetTransactionRequest struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *GetTransactionRequest) Reset()                    { *m = GetTransactionRequest{} }
func (m *GetTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTransactionRequest) ProtoMessage()               {}
func (*GetTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *GetTransactionRequest) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type GetTransactionResponse struct {
	Transaction *Transaction `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *GetTransactionResponse) Reset()                    { *m = GetTransactionResponse{} }
func (m *GetTransactionResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTransactionResponse) ProtoMessage()               {}
func (*GetTransactionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *GetTransactionResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type RemoveNodeRequest struct {
	PeerAddress string `protobuf:"bytes,1,opt,name=peer_address,json=peerAddress" json:"peer_address,omitempty"`
	PeerId      uint32 `protobuf:"varint,2,opt,name=peer_id,json=peerId" json:"peer_id,omitempty"`
}

func (m *RemoveNodeRequest) Reset()                    { *m = RemoveNodeRequest{} }
func (m *RemoveNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveNodeRequest) ProtoMessage()               {}
func (*RemoveNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *RemoveNodeRequest) GetPeerAddress() string {
	if m != nil {
		return m.PeerAddress
	}
	return ""
}

func (m *RemoveNodeRequest) GetPeerId() uint32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

type RemoveNodeResponse struct {
}

func (m *RemoveNodeResponse) Reset()                    { *m = RemoveNodeResponse{} }
func (m *RemoveNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveNodeResponse) ProtoMessage()               {}
func (*RemoveNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

type RescanBlocksRequest struct {
	Blocks []*BlockLocator `protobuf:"bytes,1,rep,name=blocks" json:"blocks,omitempty"`
}

func (m *RescanBlocksRequest) Reset()                    { *m = RescanBlocksRequest{} }
func (m *RescanBlocksRequest) String() string            { return proto.CompactTextString(m) }
func (*RescanBlocksRequest) ProtoMessage()               {}
func (*RescanBlocksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *RescanBlocksRequest) GetBlocks() []*BlockLocator {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type RescanTransactionsRequest struct {
	StartBlock *BlockLocator      `protobuf:"bytes,1,opt,name=start_block,json=startBlock" json:"start_block,omitempty"`
	StopBlock  *BlockLocator      `protobuf:"bytes,2,opt,name=stop_block,json=stopBlock" json:"stop_block,omitempty"`
	Filter     *TransactionFilter `protobuf:"bytes,3,opt,name=filter" json:"filter,omitempty"`
}

func (m *RescanTransactionsRequest) Reset()                    { *m = RescanTransactionsRequest{} }
func (m *RescanTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*RescanTransactionsRequest) ProtoMessage()               {}
func (*RescanTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *RescanTransactionsRequest) GetStartBlock() *BlockLocator {
	if m != nil {
		return m.StartBlock
	}
	return nil
}

func (m *RescanTransactionsRequest) GetStopBlock() *BlockLocator {
	if m != nil {
		return m.StopBlock
	}
	return nil
}

func (m *RescanTransactionsRequest) GetFilter() *TransactionFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

type SetGenerateRequest struct {
	Generate bool `protobuf:"varint,1,opt,name=generate" json:"generate,omitempty"`
	// TODO(stevenroose) since mining is only done is regtest, does this still make sense?
	NbWorkers     int32  `protobuf:"varint,2,opt,name=nb_workers,json=nbWorkers" json:"nb_workers,omitempty"`
	PayoutAddress string `protobuf:"bytes,3,opt,name=payout_address,json=payoutAddress" json:"payout_address,omitempty"`
}

func (m *SetGenerateRequest) Reset()                    { *m = SetGenerateRequest{} }
func (m *SetGenerateRequest) String() string            { return proto.CompactTextString(m) }
func (*SetGenerateRequest) ProtoMessage()               {}
func (*SetGenerateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *SetGenerateRequest) GetGenerate() bool {
	if m != nil {
		return m.Generate
	}
	return false
}

func (m *SetGenerateRequest) GetNbWorkers() int32 {
	if m != nil {
		return m.NbWorkers
	}
	return 0
}

func (m *SetGenerateRequest) GetPayoutAddress() string {
	if m != nil {
		return m.PayoutAddress
	}
	return ""
}

type SetGenerateResponse struct {
}

func (m *SetGenerateResponse) Reset()                    { *m = SetGenerateResponse{} }
func (m *SetGenerateResponse) String() string            { return proto.CompactTextString(m) }
func (*SetGenerateResponse) ProtoMessage()               {}
func (*SetGenerateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

type SearchTransactionsRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	Skip    int32  `protobuf:"varint,2,opt,name=skip" json:"skip,omitempty"`
	Limit   int32  `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
	// Provide the transactions in encoded form.
	Encoded bool `protobuf:"varint,4,opt,name=encoded" json:"encoded,omitempty"`
}

func (m *SearchTransactionsRequest) Reset()                    { *m = SearchTransactionsRequest{} }
func (m *SearchTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchTransactionsRequest) ProtoMessage()               {}
func (*SearchTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *SearchTransactionsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *SearchTransactionsRequest) GetSkip() int32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

func (m *SearchTransactionsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchTransactionsRequest) GetEncoded() bool {
	if m != nil {
		return m.Encoded
	}
	return false
}

type SearchTransactionsResponse struct {
	Transactions []*Transaction `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty"`
	Encoded      [][]byte       `protobuf:"bytes,2,rep,name=encoded,proto3" json:"encoded,omitempty"`
}

func (m *SearchTransactionsResponse) Reset()                    { *m = SearchTransactionsResponse{} }
func (m *SearchTransactionsResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchTransactionsResponse) ProtoMessage()               {}
func (*SearchTransactionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *SearchTransactionsResponse) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *SearchTransactionsResponse) GetEncoded() [][]byte {
	if m != nil {
		return m.Encoded
	}
	return nil
}

type SubmitTransactionRequest struct {
	Transaction []byte `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
}

func (m *SubmitTransactionRequest) Reset()                    { *m = SubmitTransactionRequest{} }
func (m *SubmitTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitTransactionRequest) ProtoMessage()               {}
func (*SubmitTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *SubmitTransactionRequest) GetTransaction() []byte {
	if m != nil {
		return m.Transaction
	}
	return nil
}

type SubmitTransactionResponse struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *SubmitTransactionResponse) Reset()                    { *m = SubmitTransactionResponse{} }
func (m *SubmitTransactionResponse) String() string            { return proto.CompactTextString(m) }
func (*SubmitTransactionResponse) ProtoMessage()               {}
func (*SubmitTransactionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *SubmitTransactionResponse) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type GetAddressTransactionsRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Control the number of transactions to be fetched from the blockchain.
	// These controls only apply to the confirmed transactions. All unconfirmed
	// ones will be returned always.
	// TODO(stevenroose) is this worth it instead of just always returning all of
	// them?  The current implementation allows this, though. So why not.
	NbSkip  uint32 `protobuf:"varint,2,opt,name=nb_skip,json=nbSkip" json:"nb_skip,omitempty"`
	NbFetch uint32 `protobuf:"varint,3,opt,name=nb_fetch,json=nbFetch" json:"nb_fetch,omitempty"`
}

func (m *GetAddressTransactionsRequest) Reset()                    { *m = GetAddressTransactionsRequest{} }
func (m *GetAddressTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetAddressTransactionsRequest) ProtoMessage()               {}
func (*GetAddressTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *GetAddressTransactionsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetAddressTransactionsRequest) GetNbSkip() uint32 {
	if m != nil {
		return m.NbSkip
	}
	return 0
}

func (m *GetAddressTransactionsRequest) GetNbFetch() uint32 {
	if m != nil {
		return m.NbFetch
	}
	return 0
}

type GetAddressTransactionsResponse struct {
	ConfirmedTransactions   []*Transaction `protobuf:"bytes,1,rep,name=confirmed_transactions,json=confirmedTransactions" json:"confirmed_transactions,omitempty"`
	UnconfirmedTransactions []*Transaction `protobuf:"bytes,2,rep,name=unconfirmed_transactions,json=unconfirmedTransactions" json:"unconfirmed_transactions,omitempty"`
}

func (m *GetAddressTransactionsResponse) Reset()                    { *m = GetAddressTransactionsResponse{} }
func (m *GetAddressTransactionsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetAddressTransactionsResponse) ProtoMessage()               {}
func (*GetAddressTransactionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *GetAddressTransactionsResponse) GetConfirmedTransactions() []*Transaction {
	if m != nil {
		return m.ConfirmedTransactions
	}
	return nil
}

func (m *GetAddressTransactionsResponse) GetUnconfirmedTransactions() []*Transaction {
	if m != nil {
		return m.UnconfirmedTransactions
	}
	return nil
}

type GetAddressUnspentOutputsRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
}

func (m *GetAddressUnspentOutputsRequest) Reset()         { *m = GetAddressUnspentOutputsRequest{} }
func (m *GetAddressUnspentOutputsRequest) String() string { return proto.CompactTextString(m) }
func (*GetAddressUnspentOutputsRequest) ProtoMessage()    {}
func (*GetAddressUnspentOutputsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{62}
}

func (m *GetAddressUnspentOutputsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetAddressUnspentOutputsResponse struct {
	Outputs []*UnspentOutput `protobuf:"bytes,1,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *GetAddressUnspentOutputsResponse) Reset()         { *m = GetAddressUnspentOutputsResponse{} }
func (m *GetAddressUnspentOutputsResponse) String() string { return proto.CompactTextString(m) }
func (*GetAddressUnspentOutputsResponse) ProtoMessage()    {}
func (*GetAddressUnspentOutputsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{63}
}

func (m *GetAddressUnspentOutputsResponse) GetOutputs() []*UnspentOutput {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type SubmitBlockRequest struct {
	Block []byte `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *SubmitBlockRequest) Reset()                    { *m = SubmitBlockRequest{} }
func (m *SubmitBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitBlockRequest) ProtoMessage()               {}
func (*SubmitBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *SubmitBlockRequest) GetBlock() []byte {
	if m != nil {
		return m.Block
	}
	return nil
}

type SubmitBlockResponse struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *SubmitBlockResponse) Reset()                    { *m = SubmitBlockResponse{} }
func (m *SubmitBlockResponse) String() string            { return proto.CompactTextString(m) }
func (*SubmitBlockResponse) ProtoMessage()               {}
func (*SubmitBlockResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *SubmitBlockResponse) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type SubscribeBlocksRequest struct {
	// Provide full transaction info instead of only the hashes.
	FullTransactions bool `protobuf:"varint,1,opt,name=full_transactions,json=fullTransactions" json:"full_transactions,omitempty"`
}

func (m *SubscribeBlocksRequest) Reset()                    { *m = SubscribeBlocksRequest{} }
func (m *SubscribeBlocksRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeBlocksRequest) ProtoMessage()               {}
func (*SubscribeBlocksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *SubscribeBlocksRequest) GetFullTransactions() bool {
	if m != nil {
		return m.FullTransactions
	}
	return false
}

type SubscribeTransactionsRequest struct {
	Subscribe   *TransactionFilter `protobuf:"bytes,1,opt,name=subscribe" json:"subscribe,omitempty"`
	Unsubscribe *TransactionFilter `protobuf:"bytes,2,opt,name=unsubscribe" json:"unsubscribe,omitempty"`
	// When this is true, also new transactions coming in from the mempool are
	// included apart from the ones confirmed in a block.  These transactions
	// will be sent again when they are confirmed.
	IncludeMempool bool `protobuf:"varint,3,opt,name=include_mempool,json=includeMempool" json:"include_mempool,omitempty"`
}

func (m *SubscribeTransactionsRequest) Reset()                    { *m = SubscribeTransactionsRequest{} }
func (m *SubscribeTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeTransactionsRequest) ProtoMessage()               {}
func (*SubscribeTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *SubscribeTransactionsRequest) GetSubscribe() *TransactionFilter {
	if m != nil {
		return m.Subscribe
	}
	return nil
}

func (m *SubscribeTransactionsRequest) GetUnsubscribe() *TransactionFilter {
	if m != nil {
		return m.Unsubscribe
	}
	return nil
}

func (m *SubscribeTransactionsRequest) GetIncludeMempool() bool {
	if m != nil {
		return m.IncludeMempool
	}
	return false
}

type StopDaemonRequest struct {
}

func (m *StopDaemonRequest) Reset()                    { *m = StopDaemonRequest{} }
func (m *StopDaemonRequest) String() string            { return proto.CompactTextString(m) }
func (*StopDaemonRequest) ProtoMessage()               {}
func (*StopDaemonRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

type StopDaemonResponse struct {
}

func (m *StopDaemonResponse) Reset()                    { *m = StopDaemonResponse{} }
func (m *StopDaemonResponse) String() string            { return proto.CompactTextString(m) }
func (*StopDaemonResponse) ProtoMessage()               {}
func (*StopDaemonResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

func init() {
	proto.RegisterType((*Block)(nil), "btcrpc.Block")
	proto.RegisterType((*BlockInfo)(nil), "btcrpc.BlockInfo")
	proto.RegisterType((*BlockLocator)(nil), "btcrpc.BlockLocator")
	proto.RegisterType((*NodeInfo)(nil), "btcrpc.NodeInfo")
	proto.RegisterType((*NodeInfo_Address)(nil), "btcrpc.NodeInfo.Address")
	proto.RegisterType((*Transaction)(nil), "btcrpc.Transaction")
	proto.RegisterType((*Transaction_Input)(nil), "btcrpc.Transaction.Input")
	proto.RegisterType((*Transaction_Input_Outpoint)(nil), "btcrpc.Transaction.Input.Outpoint")
	proto.RegisterType((*Transaction_Output)(nil), "btcrpc.Transaction.Output")
	proto.RegisterType((*TransactionFilter)(nil), "btcrpc.TransactionFilter")
	proto.RegisterType((*MempoolTransaction)(nil), "btcrpc.MempoolTransaction")
	proto.RegisterType((*UnspentOutput)(nil), "btcrpc.UnspentOutput")
	proto.RegisterType((*BlockNotification)(nil), "btcrpc.BlockNotification")
	proto.RegisterType((*TransactionNotification)(nil), "btcrpc.TransactionNotification")
	proto.RegisterType((*ConnectPeerRequest)(nil), "btcrpc.ConnectPeerRequest")
	proto.RegisterType((*ConnectPeerResponse)(nil), "btcrpc.ConnectPeerResponse")
	proto.RegisterType((*SetDebugLevelRequest)(nil), "btcrpc.SetDebugLevelRequest")
	proto.RegisterType((*SetDebugLevelResponse)(nil), "btcrpc.SetDebugLevelResponse")
	proto.RegisterType((*DisconnectPeerRequest)(nil), "btcrpc.DisconnectPeerRequest")
	proto.RegisterType((*DisconnectPeerResponse)(nil), "btcrpc.DisconnectPeerResponse")
	proto.RegisterType((*GenerateBlocksRequest)(nil), "btcrpc.GenerateBlocksRequest")
	proto.RegisterType((*GenerateBlocksResponse)(nil), "btcrpc.GenerateBlocksResponse")
	proto.RegisterType((*GetBestBlockInfoRequest)(nil), "btcrpc.GetBestBlockInfoRequest")
	proto.RegisterType((*GetBestBlockInfoResponse)(nil), "btcrpc.GetBestBlockInfoResponse")
	proto.RegisterType((*GetBlockRequest)(nil), "btcrpc.GetBlockRequest")
	proto.RegisterType((*GetBlockResponse)(nil), "btcrpc.GetBlockResponse")
	proto.RegisterType((*GetBlockCountRequest)(nil), "btcrpc.GetBlockCountRequest")
	proto.RegisterType((*GetBlockCountResponse)(nil), "btcrpc.GetBlockCountResponse")
	proto.RegisterType((*GetBlockInfoRequest)(nil), "btcrpc.GetBlockInfoRequest")
	proto.RegisterType((*GetBlockInfoResponse)(nil), "btcrpc.GetBlockInfoResponse")
	proto.RegisterType((*GetGenerateInfoRequest)(nil), "btcrpc.GetGenerateInfoRequest")
	proto.RegisterType((*GetGenerateInfoResponse)(nil), "btcrpc.GetGenerateInfoResponse")
	proto.RegisterType((*GetMempoolRequest)(nil), "btcrpc.GetMempoolRequest")
	proto.RegisterType((*GetMempoolResponse)(nil), "btcrpc.GetMempoolResponse")
	proto.RegisterType((*GetMempoolInfoRequest)(nil), "btcrpc.GetMempoolInfoRequest")
	proto.RegisterType((*GetMempoolInfoResponse)(nil), "btcrpc.GetMempoolInfoResponse")
	proto.RegisterType((*GetMiningInfoRequest)(nil), "btcrpc.GetMiningInfoRequest")
	proto.RegisterType((*GetMiningInfoResponse)(nil), "btcrpc.GetMiningInfoResponse")
	proto.RegisterType((*GetNetworkHashRateRequest)(nil), "btcrpc.GetNetworkHashRateRequest")
	proto.RegisterType((*GetNetworkHashRateResponse)(nil), "btcrpc.GetNetworkHashRateResponse")
	proto.RegisterType((*GetNetworkInfoRequest)(nil), "btcrpc.GetNetworkInfoRequest")
	proto.RegisterType((*GetNetworkInfoResponse)(nil), "btcrpc.GetNetworkInfoResponse")
	proto.RegisterType((*GetPeersRequest)(nil), "btcrpc.GetPeersRequest")
	proto.RegisterType((*GetPeersResponse)(nil), "btcrpc.GetPeersResponse")
	proto.RegisterType((*GetPeersResponse_PeerInfo)(nil), "btcrpc.GetPeersResponse.PeerInfo")
	proto.RegisterType((*GetRawBlockRequest)(nil), "btcrpc.GetRawBlockRequest")
	proto.RegisterType((*GetRawBlockResponse)(nil), "btcrpc.GetRawBlockResponse")
	proto.RegisterType((*GetRawMempoolRequest)(nil), "btcrpc.GetRawMempoolRequest")
	proto.RegisterType((*GetRawMempoolResponse)(nil), "btcrpc.GetRawMempoolResponse")
	proto.RegisterType((*GetRawTransactionRequest)(nil), "btcrpc.GetRawTransactionRequest")
	proto.RegisterType((*GetRawTransactionResponse)(nil), "btcrpc.GetRawTransactionResponse")
	proto.RegisterType((*GetSystemInfoRequest)(nil), "btcrpc.GetSystemInfoRequest")
	proto.RegisterType((*GetSystemInfoResponse)(nil), "btcrpc.GetSystemInfoResponse")
	proto.RegisterType((*GetTransactionRequest)(nil), "btcrpc.GetTransactionRequest")
	proto.RegisterType((*GetTransactionResponse)(nil), "btcrpc.GetTransactionResponse")
	proto.RegisterType((*RemoveNodeRequest)(nil), "btcrpc.RemoveNodeRequest")
	proto.RegisterType((*RemoveNodeResponse)(nil), "btcrpc.RemoveNodeResponse")
	proto.RegisterType((*RescanBlocksRequest)(nil), "btcrpc.RescanBlocksRequest")
	proto.RegisterType((*RescanTransactionsRequest)(nil), "btcrpc.RescanTransactionsRequest")
	proto.RegisterType((*SetGenerateRequest)(nil), "btcrpc.SetGenerateRequest")
	proto.RegisterType((*SetGenerateResponse)(nil), "btcrpc.SetGenerateResponse")
	proto.RegisterType((*SearchTransactionsRequest)(nil), "btcrpc.SearchTransactionsRequest")
	proto.RegisterType((*SearchTransactionsResponse)(nil), "btcrpc.SearchTransactionsResponse")
	proto.RegisterType((*SubmitTransactionRequest)(nil), "btcrpc.SubmitTransactionRequest")
	proto.RegisterType((*SubmitTransactionResponse)(nil), "btcrpc.SubmitTransactionResponse")
	proto.RegisterType((*GetAddressTransactionsRequest)(nil), "btcrpc.GetAddressTransactionsRequest")
	proto.RegisterType((*GetAddressTransactionsResponse)(nil), "btcrpc.GetAddressTransactionsResponse")
	proto.RegisterType((*GetAddressUnspentOutputsRequest)(nil), "btcrpc.GetAddressUnspentOutputsRequest")
	proto.RegisterType((*GetAddressUnspentOutputsResponse)(nil), "btcrpc.GetAddressUnspentOutputsResponse")
	proto.RegisterType((*SubmitBlockRequest)(nil), "btcrpc.SubmitBlockRequest")
	proto.RegisterType((*SubmitBlockResponse)(nil), "btcrpc.SubmitBlockResponse")
	proto.RegisterType((*SubscribeBlocksRequest)(nil), "btcrpc.SubscribeBlocksRequest")
	proto.RegisterType((*SubscribeTransactionsRequest)(nil), "btcrpc.SubscribeTransactionsRequest")
	proto.RegisterType((*StopDaemonRequest)(nil), "btcrpc.StopDaemonRequest")
	proto.RegisterType((*StopDaemonResponse)(nil), "btcrpc.StopDaemonResponse")
	proto.RegisterEnum("btcrpc.NodeInfo_ConnectedStatus", NodeInfo_ConnectedStatus_name, NodeInfo_ConnectedStatus_value)
	proto.RegisterEnum("btcrpc.BlockNotification_Type", BlockNotification_Type_name, BlockNotification_Type_value)
	proto.RegisterEnum("btcrpc.TransactionNotification_Type", TransactionNotification_Type_name, TransactionNotification_Type_value)
	proto.RegisterEnum("btcrpc.SetDebugLevelRequest_DebugLevel", SetDebugLevelRequest_DebugLevel_name, SetDebugLevelRequest_DebugLevel_value)
	proto.RegisterEnum("btcrpc.SetDebugLevelRequest_Subsystem", SetDebugLevelRequest_Subsystem_name, SetDebugLevelRequest_Subsystem_value)
	proto.RegisterEnum("btcrpc.GetNetworkInfoResponse_BitcoinNet", GetNetworkInfoResponse_BitcoinNet_name, GetNetworkInfoResponse_BitcoinNet_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Btcd service

type BtcdClient interface {
	// Get various system and runtime-related info.
	GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error)
	// Set the debug level of the daemon.
	SetDebugLevel(ctx context.Context, in *SetDebugLevelRequest, opts ...grpc.CallOption) (*SetDebugLevelResponse, error)
	// Stop the daemon.
	StopDaemon(ctx context.Context, in *StopDaemonRequest, opts ...grpc.CallOption) (*StopDaemonResponse, error)
	// Get various state info.
	// TODO(stevenroose) merge with GetSystemInfo into GetInfo maybe?
	GetNetworkInfo(ctx context.Context, in *GetNetworkInfoRequest, opts ...grpc.CallOption) (*GetNetworkInfoResponse, error)
	// Get the total hashrate of the network.
	GetNetworkHashRate(ctx context.Context, in *GetNetworkHashRateRequest, opts ...grpc.CallOption) (*GetNetworkHashRateResponse, error)
	// Get info about the mempool.
	GetMempoolInfo(ctx context.Context, in *GetMempoolInfoRequest, opts ...grpc.CallOption) (*GetMempoolInfoResponse, error)
	// Get the transactions in the mempool.
	GetMempool(ctx context.Context, in *GetMempoolRequest, opts ...grpc.CallOption) (*GetMempoolResponse, error)
	// Get all mempool transactions in serialized format.
	// TODO(stevenroose) should this be a streaming response because of the size?
	GetRawMempool(ctx context.Context, in *GetRawMempoolRequest, opts ...grpc.CallOption) (*GetRawMempoolResponse, error)
	// Get info about the most recent block in the longest blockchain.
	GetBestBlockInfo(ctx context.Context, in *GetBestBlockInfoRequest, opts ...grpc.CallOption) (*GetBestBlockInfoResponse, error)
	// Get info about the given block.
	GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error)
	// Get a block.
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
	// Get a serialized block.
	GetRawBlock(ctx context.Context, in *GetRawBlockRequest, opts ...grpc.CallOption) (*GetRawBlockResponse, error)
	// Submit the block to all connected peers.
	SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error)
	// Get a transaction given its hash.
	// This call requires the transaction index to be enabled to be able to
	// find transactions that are noto in the mempool.
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// Get a serialized transaction given its hash.
	// This call requires the transaction index to be enabled to be able to
	// find transactions that are noto in the mempool.
	GetRawTransaction(ctx context.Context, in *GetRawTransactionRequest, opts ...grpc.CallOption) (*GetRawTransactionResponse, error)
	// Rescan part of the blockchain for relevant transactions.
	// TODO(stevenroose) are progress updates useful?
	//  could make a response message that is a oneof tx or update
	// TODO(stevenroose) should there be more info than simply the tx?
	//  like incoming or outgoing, ...
	RescanTransactions(ctx context.Context, in *RescanTransactionsRequest, opts ...grpc.CallOption) (Btcd_RescanTransactionsClient, error)
	// Submit a transaction to all connected peers.
	SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error)
	// Returns all known transactions for the given address.
	//
	// This method requires the address and transaction index.
	GetAddressTransactions(ctx context.Context, in *GetAddressTransactionsRequest, opts ...grpc.CallOption) (*GetAddressTransactionsResponse, error)
	// Returns all the unspent transaction outpoints for the given address.
	//
	// This method requires the address and transaction index.
	GetAddressUnspentOutputs(ctx context.Context, in *GetAddressUnspentOutputsRequest, opts ...grpc.CallOption) (*GetAddressUnspentOutputsResponse, error)
	// Subscribe to relevant transactions based on the subscription requests.
	// The parameters to filter transactions on can be updated by sending new
	// SubscribeTransactionsRequest objects on the stream.
	SubscribeTransactions(ctx context.Context, opts ...grpc.CallOption) (Btcd_SubscribeTransactionsClient, error)
	// Subscribe to notifications of new blocks being connected to the blockchain
	// or blocks being disconnected.
	// TODO(stevenroose) give option to not get disconnected blocks?
	SubscribeBlocks(ctx context.Context, in *SubscribeBlocksRequest, opts ...grpc.CallOption) (Btcd_SubscribeBlocksClient, error)
	// Get info about the peers this node is connected to.
	// Set permanent to get the permanent peer list.
	GetPeers(ctx context.Context, in *GetPeersRequest, opts ...grpc.CallOption) (*GetPeersResponse, error)
	// Connect to a new peer.
	// Set permanent to true to add to permanent peer list.
	// TODO(stevenroose) is it worth/possible to have a flag to make it a blocking
	// call with a success flag
	ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error)
	// Disconnect from a peer.
	// Set permanent to true to remove from permanent peer list.
	DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error)
	// Get info related to the miner.
	GetMiningInfo(ctx context.Context, in *GetMiningInfoRequest, opts ...grpc.CallOption) (*GetMiningInfoResponse, error)
}

type btcdClient struct {
	cc *grpc.ClientConn
}

func NewBtcdClient(cc *grpc.ClientConn) BtcdClient {
	return &btcdClient{cc}
}

func (c *btcdClient) GetSystemInfo(ctx context.Context, in *GetSystemInfoRequest, opts ...grpc.CallOption) (*GetSystemInfoResponse, error) {
	out := new(GetSystemInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetSystemInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) SetDebugLevel(ctx context.Context, in *SetDebugLevelRequest, opts ...grpc.CallOption) (*SetDebugLevelResponse, error) {
	out := new(SetDebugLevelResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/SetDebugLevel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) StopDaemon(ctx context.Context, in *StopDaemonRequest, opts ...grpc.CallOption) (*StopDaemonResponse, error) {
	out := new(StopDaemonResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/StopDaemon", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetNetworkInfo(ctx context.Context, in *GetNetworkInfoRequest, opts ...grpc.CallOption) (*GetNetworkInfoResponse, error) {
	out := new(GetNetworkInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetNetworkInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetNetworkHashRate(ctx context.Context, in *GetNetworkHashRateRequest, opts ...grpc.CallOption) (*GetNetworkHashRateResponse, error) {
	out := new(GetNetworkHashRateResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetNetworkHashRate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetMempoolInfo(ctx context.Context, in *GetMempoolInfoRequest, opts ...grpc.CallOption) (*GetMempoolInfoResponse, error) {
	out := new(GetMempoolInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetMempoolInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetMempool(ctx context.Context, in *GetMempoolRequest, opts ...grpc.CallOption) (*GetMempoolResponse, error) {
	out := new(GetMempoolResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetMempool", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetRawMempool(ctx context.Context, in *GetRawMempoolRequest, opts ...grpc.CallOption) (*GetRawMempoolResponse, error) {
	out := new(GetRawMempoolResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetRawMempool", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetBestBlockInfo(ctx context.Context, in *GetBestBlockInfoRequest, opts ...grpc.CallOption) (*GetBestBlockInfoResponse, error) {
	out := new(GetBestBlockInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetBestBlockInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error) {
	out := new(GetBlockInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetBlockInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) {
	out := new(GetBlockResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetRawBlock(ctx context.Context, in *GetRawBlockRequest, opts ...grpc.CallOption) (*GetRawBlockResponse, error) {
	out := new(GetRawBlockResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetRawBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) SubmitBlock(ctx context.Context, in *SubmitBlockRequest, opts ...grpc.CallOption) (*SubmitBlockResponse, error) {
	out := new(SubmitBlockResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/SubmitBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetRawTransaction(ctx context.Context, in *GetRawTransactionRequest, opts ...grpc.CallOption) (*GetRawTransactionResponse, error) {
	out := new(GetRawTransactionResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetRawTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) RescanTransactions(ctx context.Context, in *RescanTransactionsRequest, opts ...grpc.CallOption) (Btcd_RescanTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Btcd_serviceDesc.Streams[0], c.cc, "/btcrpc.btcd/RescanTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &btcdRescanTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Btcd_RescanTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type btcdRescanTransactionsClient struct {
	grpc.ClientStream
}

func (x *btcdRescanTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *btcdClient) SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error) {
	out := new(SubmitTransactionResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/SubmitTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetAddressTransactions(ctx context.Context, in *GetAddressTransactionsRequest, opts ...grpc.CallOption) (*GetAddressTransactionsResponse, error) {
	out := new(GetAddressTransactionsResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetAddressTransactions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetAddressUnspentOutputs(ctx context.Context, in *GetAddressUnspentOutputsRequest, opts ...grpc.CallOption) (*GetAddressUnspentOutputsResponse, error) {
	out := new(GetAddressUnspentOutputsResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetAddressUnspentOutputs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) SubscribeTransactions(ctx context.Context, opts ...grpc.CallOption) (Btcd_SubscribeTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Btcd_serviceDesc.Streams[1], c.cc, "/btcrpc.btcd/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &btcdSubscribeTransactionsClient{stream}
	return x, nil
}

type Btcd_SubscribeTransactionsClient interface {
	Send(*SubscribeTransactionsRequest) error
	Recv() (*TransactionNotification, error)
	grpc.ClientStream
}

type btcdSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *btcdSubscribeTransactionsClient) Send(m *SubscribeTransactionsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *btcdSubscribeTransactionsClient) Recv() (*TransactionNotification, error) {
	m := new(TransactionNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *btcdClient) SubscribeBlocks(ctx context.Context, in *SubscribeBlocksRequest, opts ...grpc.CallOption) (Btcd_SubscribeBlocksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Btcd_serviceDesc.Streams[2], c.cc, "/btcrpc.btcd/SubscribeBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &btcdSubscribeBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Btcd_SubscribeBlocksClient interface {
	Recv() (*BlockNotification, error)
	grpc.ClientStream
}

type btcdSubscribeBlocksClient struct {
	grpc.ClientStream
}

func (x *btcdSubscribeBlocksClient) Recv() (*BlockNotification, error) {
	m := new(BlockNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *btcdClient) GetPeers(ctx context.Context, in *GetPeersRequest, opts ...grpc.CallOption) (*GetPeersResponse, error) {
	out := new(GetPeersResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {
	out := new(ConnectPeerResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/ConnectPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error) {
	out := new(DisconnectPeerResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/DisconnectPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *btcdClient) GetMiningInfo(ctx context.Context, in *GetMiningInfoRequest, opts ...grpc.CallOption) (*GetMiningInfoResponse, error) {
	out := new(GetMiningInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.btcd/GetMiningInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Btcd service

type BtcdServer interface {
	// Get various system and runtime-related info.
	GetSystemInfo(context.Context, *GetSystemInfoRequest) (*GetSystemInfoResponse, error)
	// Set the debug level of the daemon.
	SetDebugLevel(context.Context, *SetDebugLevelRequest) (*SetDebugLevelResponse, error)
	// Stop the daemon.
	StopDaemon(context.Context, *StopDaemonRequest) (*StopDaemonResponse, error)
	// Get various state info.
	// TODO(stevenroose) merge with GetSystemInfo into GetInfo maybe?
	GetNetworkInfo(context.Context, *GetNetworkInfoRequest) (*GetNetworkInfoResponse, error)
	// Get the total hashrate of the network.
	GetNetworkHashRate(context.Context, *GetNetworkHashRateRequest) (*GetNetworkHashRateResponse, error)
	// Get info about the mempool.
	GetMempoolInfo(context.Context, *GetMempoolInfoRequest) (*GetMempoolInfoResponse, error)
	// Get the transactions in the mempool.
	GetMempool(context.Context, *GetMempoolRequest) (*GetMempoolResponse, error)
	// Get all mempool transactions in serialized format.
	// TODO(stevenroose) should this be a streaming response because of the size?
	GetRawMempool(context.Context, *GetRawMempoolRequest) (*GetRawMempoolResponse, error)
	// Get info about the most recent block in the longest blockchain.
	GetBestBlockInfo(context.Context, *GetBestBlockInfoRequest) (*GetBestBlockInfoResponse, error)
	// Get info about the given block.
	GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error)
	// Get a block.
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
	// Get a serialized block.
	GetRawBlock(context.Context, *GetRawBlockRequest) (*GetRawBlockResponse, error)
	// Submit the block to all connected peers.
	SubmitBlock(context.Context, *SubmitBlockRequest) (*SubmitBlockResponse, error)
	// Get a transaction given its hash.
	// This call requires the transaction index to be enabled to be able to
	// find transactions that are noto in the mempool.
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	// Get a serialized transaction given its hash.
	// This call requires the transaction index to be enabled to be able to
	// find transactions that are noto in the mempool.
	GetRawTransaction(context.Context, *GetRawTransactionRequest) (*GetRawTransactionResponse, error)
	// Rescan part of the blockchain for relevant transactions.
	// TODO(stevenroose) are progress updates useful?
	//  could make a response message that is a oneof tx or update
	// TODO(stevenroose) should there be more info than simply the tx?
	//  like incoming or outgoing, ...
	RescanTransactions(*RescanTransactionsRequest, Btcd_RescanTransactionsServer) error
	// Submit a transaction to all connected peers.
	SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error)
	// Returns all known transactions for the given address.
	//
	// This method requires the address and transaction index.
	GetAddressTransactions(context.Context, *GetAddressTransactionsRequest) (*GetAddressTransactionsResponse, error)
	// Returns all the unspent transaction outpoints for the given address.
	//
	// This method requires the address and transaction index.
	GetAddressUnspentOutputs(context.Context, *GetAddressUnspentOutputsRequest) (*GetAddressUnspentOutputsResponse, error)
	// Subscribe to relevant transactions based on the subscription requests.
	// The parameters to filter transactions on can be updated by sending new
	// SubscribeTransactionsRequest objects on the stream.
	SubscribeTransactions(Btcd_SubscribeTransactionsServer) error
	// Subscribe to notifications of new blocks being connected to the blockchain
	// or blocks being disconnected.
	// TODO(stevenroose) give option to not get disconnected blocks?
	SubscribeBlocks(*SubscribeBlocksRequest, Btcd_SubscribeBlocksServer) error
	// Get info about the peers this node is connected to.
	// Set permanent to get the permanent peer list.
	GetPeers(context.Context, *GetPeersRequest) (*GetPeersResponse, error)
	// Connect to a new peer.
	// Set permanent to true to add to permanent peer list.
	// TODO(stevenroose) is it worth/possible to have a flag to make it a blocking
	// call with a success flag
	ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error)
	// Disconnect from a peer.
	// Set permanent to true to remove from permanent peer list.
	DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error)
	// Get info related to the miner.
	GetMiningInfo(context.Context, *GetMiningInfoRequest) (*GetMiningInfoResponse, error)
}

func RegisterBtcdServer(s *grpc.Server, srv BtcdServer) {
	s.RegisterService(&_Btcd_serviceDesc, srv)
}

func _Btcd_GetSystemInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetSystemInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetSystemInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetSystemInfo(ctx, req.(*GetSystemInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_SetDebugLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDebugLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).SetDebugLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/SetDebugLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).SetDebugLevel(ctx, req.(*SetDebugLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopDaemonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).StopDaemon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/StopDaemon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).StopDaemon(ctx, req.(*StopDaemonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetNetworkInfo(ctx, req.(*GetNetworkInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetNetworkHashRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkHashRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetNetworkHashRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetNetworkHashRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetNetworkHashRate(ctx, req.(*GetNetworkHashRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetMempoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMempoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetMempoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetMempoolInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetMempoolInfo(ctx, req.(*GetMempoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetMempool(ctx, req.(*GetMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetRawMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetRawMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetRawMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetRawMempool(ctx, req.(*GetRawMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetBestBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBestBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetBestBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetBestBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetBestBlockInfo(ctx, req.(*GetBestBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetBlockInfo(ctx, req.(*GetBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetRawBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetRawBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetRawBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetRawBlock(ctx, req.(*GetRawBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_SubmitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).SubmitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/SubmitBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).SubmitBlock(ctx, req.(*SubmitBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetRawTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetRawTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetRawTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetRawTransaction(ctx, req.(*GetRawTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_RescanTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RescanTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BtcdServer).RescanTransactions(m, &btcdRescanTransactionsServer{stream})
}

type Btcd_RescanTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type btcdRescanTransactionsServer struct {
	grpc.ServerStream
}

func (x *btcdRescanTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func _Btcd_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/SubmitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).SubmitTransaction(ctx, req.(*SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetAddressTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetAddressTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetAddressTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetAddressTransactions(ctx, req.(*GetAddressTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetAddressUnspentOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressUnspentOutputsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetAddressUnspentOutputs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetAddressUnspentOutputs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetAddressUnspentOutputs(ctx, req.(*GetAddressUnspentOutputsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BtcdServer).SubscribeTransactions(&btcdSubscribeTransactionsServer{stream})
}

type Btcd_SubscribeTransactionsServer interface {
	Send(*TransactionNotification) error
	Recv() (*SubscribeTransactionsRequest, error)
	grpc.ServerStream
}

type btcdSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *btcdSubscribeTransactionsServer) Send(m *TransactionNotification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *btcdSubscribeTransactionsServer) Recv() (*SubscribeTransactionsRequest, error) {
	m := new(SubscribeTransactionsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Btcd_SubscribeBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BtcdServer).SubscribeBlocks(m, &btcdSubscribeBlocksServer{stream})
}

type Btcd_SubscribeBlocksServer interface {
	Send(*BlockNotification) error
	grpc.ServerStream
}

type btcdSubscribeBlocksServer struct {
	grpc.ServerStream
}

func (x *btcdSubscribeBlocksServer) Send(m *BlockNotification) error {
	return x.ServerStream.SendMsg(m)
}

func _Btcd_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetPeers(ctx, req.(*GetPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).ConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/ConnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).ConnectPeer(ctx, req.(*ConnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_DisconnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).DisconnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/DisconnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).DisconnectPeer(ctx, req.(*DisconnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Btcd_GetMiningInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMiningInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BtcdServer).GetMiningInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.btcd/GetMiningInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BtcdServer).GetMiningInfo(ctx, req.(*GetMiningInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Btcd_serviceDesc = grpc.ServiceDesc{
	ServiceName: "btcrpc.btcd",
	HandlerType: (*BtcdServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSystemInfo",
			Handler:    _Btcd_GetSystemInfo_Handler,
		},
		{
			MethodName: "SetDebugLevel",
			Handler:    _Btcd_SetDebugLevel_Handler,
		},
		{
			MethodName: "StopDaemon",
			Handler:    _Btcd_StopDaemon_Handler,
		},
		{
			MethodName: "GetNetworkInfo",
			Handler:    _Btcd_GetNetworkInfo_Handler,
		},
		{
			MethodName: "GetNetworkHashRate",
			Handler:    _Btcd_GetNetworkHashRate_Handler,
		},
		{
			MethodName: "GetMempoolInfo",
			Handler:    _Btcd_GetMempoolInfo_Handler,
		},
		{
			MethodName: "GetMempool",
			Handler:    _Btcd_GetMempool_Handler,
		},
		{
			MethodName: "GetRawMempool",
			Handler:    _Btcd_GetRawMempool_Handler,
		},
		{
			MethodName: "GetBestBlockInfo",
			Handler:    _Btcd_GetBestBlockInfo_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _Btcd_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _Btcd_GetBlock_Handler,
		},
		{
			MethodName: "GetRawBlock",
			Handler:    _Btcd_GetRawBlock_Handler,
		},
		{
			MethodName: "SubmitBlock",
			Handler:    _Btcd_SubmitBlock_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _Btcd_GetTransaction_Handler,
		},
		{
			MethodName: "GetRawTransaction",
			Handler:    _Btcd_GetRawTransaction_Handler,
		},
		{
			MethodName: "SubmitTransaction",
			Handler:    _Btcd_SubmitTransaction_Handler,
		},
		{
			MethodName: "GetAddressTransactions",
			Handler:    _Btcd_GetAddressTransactions_Handler,
		},
		{
			MethodName: "GetAddressUnspentOutputs",
			Handler:    _Btcd_GetAddressUnspentOutputs_Handler,
		},
		{
			MethodName: "GetPeers",
			Handler:    _Btcd_GetPeers_Handler,
		},
		{
			MethodName: "ConnectPeer",
			Handler:    _Btcd_ConnectPeer_Handler,
		},
		{
			MethodName: "DisconnectPeer",
			Handler:    _Btcd_DisconnectPeer_Handler,
		},
		{
			MethodName: "GetMiningInfo",
			Handler:    _Btcd_GetMiningInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RescanTransactions",
			Handler:       _Btcd_RescanTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _Btcd_SubscribeTransactions_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeBlocks",
			Handler:       _Btcd_SubscribeBlocks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "btcrpc.proto",
}

// Client API for Regtest service

type RegtestClient interface {
	// Set the properties for the built-in CPR miner.
	// Also allows to add new payout addresses.
	SetGenerate(ctx context.Context, in *SetGenerateRequest, opts ...grpc.CallOption) (*SetGenerateResponse, error)
	// Get info about the CPU block generator.
	GetGenerateInfo(ctx context.Context, in *GetGenerateInfoRequest, opts ...grpc.CallOption) (*GetGenerateInfoResponse, error)
	// Generate a number of blocks.
	// Also allows to add new payout addresses.
	GenerateBlocks(ctx context.Context, in *GenerateBlocksRequest, opts ...grpc.CallOption) (*GenerateBlocksResponse, error)
}

type regtestClient struct {
	cc *grpc.ClientConn
}

func NewRegtestClient(cc *grpc.ClientConn) RegtestClient {
	return &regtestClient{cc}
}

func (c *regtestClient) SetGenerate(ctx context.Context, in *SetGenerateRequest, opts ...grpc.CallOption) (*SetGenerateResponse, error) {
	out := new(SetGenerateResponse)
	err := grpc.Invoke(ctx, "/btcrpc.regtest/SetGenerate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regtestClient) GetGenerateInfo(ctx context.Context, in *GetGenerateInfoRequest, opts ...grpc.CallOption) (*GetGenerateInfoResponse, error) {
	out := new(GetGenerateInfoResponse)
	err := grpc.Invoke(ctx, "/btcrpc.regtest/GetGenerateInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regtestClient) GenerateBlocks(ctx context.Context, in *GenerateBlocksRequest, opts ...grpc.CallOption) (*GenerateBlocksResponse, error) {
	out := new(GenerateBlocksResponse)
	err := grpc.Invoke(ctx, "/btcrpc.regtest/GenerateBlocks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Regtest service

type RegtestServer interface {
	// Set the properties for the built-in CPR miner.
	// Also allows to add new payout addresses.
	SetGenerate(context.Context, *SetGenerateRequest) (*SetGenerateResponse, error)
	// Get info about the CPU block generator.
	GetGenerateInfo(context.Context, *GetGenerateInfoRequest) (*GetGenerateInfoResponse, error)
	// Generate a number of blocks.
	// Also allows to add new payout addresses.
	GenerateBlocks(context.Context, *GenerateBlocksRequest) (*GenerateBlocksResponse, error)
}

func RegisterRegtestServer(s *grpc.Server, srv RegtestServer) {
	s.RegisterService(&_Regtest_serviceDesc, srv)
}

func _Regtest_SetGenerate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegtestServer).SetGenerate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.regtest/SetGenerate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegtestServer).SetGenerate(ctx, req.(*SetGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Regtest_GetGenerateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGenerateInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegtestServer).GetGenerateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.regtest/GetGenerateInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegtestServer).GetGenerateInfo(ctx, req.(*GetGenerateInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Regtest_GenerateBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegtestServer).GenerateBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/btcrpc.regtest/GenerateBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegtestServer).GenerateBlocks(ctx, req.(*GenerateBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Regtest_serviceDesc = grpc.ServiceDesc{
	ServiceName: "btcrpc.regtest",
	HandlerType: (*RegtestServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetGenerate",
			Handler:    _Regtest_SetGenerate_Handler,
		},
		{
			MethodName: "GetGenerateInfo",
			Handler:    _Regtest_GetGenerateInfo_Handler,
		},
		{
			MethodName: "GenerateBlocks",
			Handler:    _Regtest_GenerateBlocks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "btcrpc.proto",
}

func init() { proto.RegisterFile("btcrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 3604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x3a, 0x4d, 0x73, 0xdb, 0x46,
	0x96, 0x04, 0xbf, 0x44, 0x3e, 0x92, 0x12, 0xd4, 0xfa, 0xa2, 0x68, 0xcb, 0x92, 0x61, 0x3b, 0x96,
	0x37, 0x59, 0xc5, 0x51, 0x92, 0x75, 0xaa, 0xbc, 0xf1, 0x46, 0xa2, 0x64, 0x4b, 0x59, 0x8b, 0xd2,
	0x36, 0xe5, 0x38, 0xd9, 0x8f, 0x62, 0x01, 0x60, 0x53, 0x42, 0x99, 0x02, 0xb8, 0x00, 0x28, 0x5b,
	0xa9, 0xda, 0xd3, 0x5e, 0xf6, 0x0f, 0xec, 0x56, 0xe5, 0xbc, 0x73, 0x98, 0x9a, 0x9f, 0x90, 0x9a,
	0x39, 0xcc, 0x61, 0xa6, 0xe6, 0x34, 0xf3, 0x23, 0xe6, 0x37, 0xcc, 0x6d, 0x0e, 0x53, 0xfd, 0x01,
	0xa0, 0x9b, 0x00, 0x65, 0x3b, 0xb9, 0xa1, 0x5f, 0xbf, 0x7e, 0xdd, 0xfd, 0xbe, 0xdf, 0x6b, 0x40,
	0xdd, 0x0a, 0x6d, 0x7f, 0x64, 0x6f, 0x8d, 0x7c, 0x2f, 0xf4, 0x50, 0x99, 0x8f, 0x8c, 0xff, 0xd3,
	0xa0, 0xb4, 0x3b, 0xf4, 0xec, 0x57, 0xe8, 0x1e, 0x14, 0x1d, 0x77, 0xe0, 0x35, 0xb5, 0x0d, 0x6d,
	0xb3, 0xb6, 0x3d, 0xbf, 0x25, 0xd0, 0xd9, 0xe4, 0xa1, 0x3b, 0xf0, 0x30, 0x9b, 0x46, 0x7f, 0x0f,
	0x28, 0xf4, 0x4d, 0x37, 0x30, 0xed, 0xd0, 0xf1, 0xdc, 0xde, 0xb9, 0x19, 0x9c, 0x93, 0xa0, 0x99,
	0xdf, 0x28, 0x6c, 0xd6, 0xf1, 0xbc, 0x34, 0x73, 0xc0, 0x26, 0xd0, 0x23, 0xa8, 0x4b, 0xc0, 0xa0,
	0x59, 0xd8, 0x28, 0x6c, 0xd6, 0xb6, 0x17, 0x22, 0xea, 0xa7, 0xc9, 0x1c, 0x56, 0x10, 0x8d, 0xdf,
	0xe5, 0xa1, 0x1a, 0xef, 0x8d, 0x10, 0x14, 0xe9, 0x4e, 0xec, 0x70, 0x75, 0xcc, 0xbe, 0xd1, 0x32,
	0x94, 0xcf, 0x89, 0x73, 0x76, 0x1e, 0x36, 0xf3, 0x1b, 0xda, 0x66, 0x09, 0x8b, 0x11, 0x6a, 0xc2,
	0xcc, 0x25, 0xf1, 0x03, 0xc7, 0x73, 0x9b, 0x05, 0x36, 0x11, 0x0d, 0xd1, 0x3d, 0x98, 0x1d, 0xf9,
	0xe4, 0xd2, 0xf1, 0xc6, 0x41, 0xcf, 0xa2, 0xb4, 0x9b, 0x45, 0x46, 0xaf, 0x11, 0x41, 0x39, 0x27,
	0xd6, 0xa1, 0x76, 0x41, 0xfc, 0x57, 0x43, 0xd2, 0xf3, 0x3d, 0x2f, 0x6c, 0x96, 0x18, 0x0e, 0x70,
	0x10, 0xf6, 0xbc, 0x90, 0x9e, 0x26, 0x74, 0x2e, 0x48, 0xb3, 0xbc, 0xa1, 0x6d, 0x16, 0x30, 0xfb,
	0xa6, 0x30, 0xcb, 0x09, 0x83, 0xe6, 0xcc, 0x86, 0xb6, 0xd9, 0xc0, 0xec, 0x1b, 0x2d, 0x42, 0xc9,
	0xf5, 0x5c, 0x9b, 0x34, 0x2b, 0x0c, 0xc8, 0x07, 0xe8, 0x2e, 0x34, 0x6c, 0xcf, 0x1d, 0x38, 0xfe,
	0x85, 0xc9, 0x79, 0x52, 0x65, 0xa7, 0x54, 0x81, 0xe8, 0x16, 0x40, 0xdf, 0x19, 0x0c, 0x1c, 0x7b,
	0x3c, 0x0c, 0xaf, 0x9a, 0xb0, 0xa1, 0x6d, 0x6a, 0x58, 0x82, 0xa0, 0x0f, 0x60, 0xce, 0x25, 0x6f,
	0x42, 0x7e, 0x0f, 0x26, 0x86, 0x66, 0x8d, 0x5f, 0x86, 0x82, 0xd9, 0x45, 0xa8, 0x08, 0x8c, 0x43,
	0xa8, 0xb3, 0xc1, 0x73, 0xcf, 0x36, 0x43, 0xcf, 0x47, 0x8b, 0x32, 0x27, 0x0f, 0x72, 0x82, 0x97,
	0x4d, 0x95, 0x97, 0x07, 0xb9, 0x88, 0x9b, 0xbb, 0x55, 0x98, 0x19, 0xf2, 0xa5, 0xc6, 0x2f, 0xf3,
	0x50, 0xe9, 0x78, 0x7d, 0xc2, 0x24, 0x72, 0x1b, 0xea, 0x23, 0x42, 0xfc, 0x9e, 0xd9, 0xef, 0xfb,
	0x24, 0x08, 0x18, 0xbd, 0x2a, 0xae, 0x51, 0xd8, 0x0e, 0x07, 0xa1, 0x9b, 0x50, 0xb5, 0x3d, 0xd7,
	0x25, 0x76, 0x48, 0xfa, 0x8c, 0x6e, 0x05, 0x27, 0x00, 0xf4, 0x0f, 0x50, 0x15, 0x6b, 0x49, 0xa4,
	0x16, 0xcd, 0x48, 0x2d, 0xa2, 0x5d, 0xb6, 0x04, 0x29, 0x9c, 0xa0, 0xb6, 0x6c, 0x98, 0x89, 0x36,
	0x68, 0xc2, 0x8c, 0xba, 0x7d, 0x34, 0x44, 0x4f, 0x26, 0xb7, 0x9e, 0xdd, 0xde, 0x48, 0x11, 0x6f,
	0x47, 0x18, 0xdd, 0xd0, 0x0c, 0xc7, 0x81, 0x74, 0x38, 0xe3, 0x09, 0xcc, 0x4d, 0xcc, 0x22, 0x1d,
	0xea, 0x7b, 0x87, 0xdd, 0xf6, 0x71, 0xa7, 0xb3, 0xdf, 0x3e, 0xdd, 0xdf, 0xd3, 0x73, 0xa8, 0x0e,
	0x95, 0xe3, 0x17, 0xa7, 0xbb, 0xc7, 0x2f, 0x3a, 0x7b, 0xba, 0x86, 0x6a, 0x30, 0x73, 0xd8, 0xe1,
	0x83, 0xbc, 0xf1, 0x97, 0x12, 0xd4, 0x24, 0xdd, 0xce, 0xd4, 0xdf, 0x5b, 0x00, 0x01, 0xf1, 0x1d,
	0x73, 0xe8, 0x7c, 0x2f, 0x0e, 0x59, 0xc7, 0x12, 0xe4, 0x1a, 0x3d, 0xfe, 0x04, 0xca, 0x8e, 0x3b,
	0x1a, 0x87, 0x41, 0xb3, 0xc8, 0xf8, 0xb6, 0x9a, 0x61, 0x4e, 0x5b, 0x87, 0x14, 0x03, 0x0b, 0x44,
	0xf4, 0x19, 0xcc, 0x78, 0xe3, 0x90, 0xad, 0x29, 0xb1, 0x35, 0xad, 0xac, 0x35, 0xc7, 0x0c, 0x05,
	0x47, 0xa8, 0xe8, 0x06, 0x54, 0x99, 0x7a, 0xc5, 0xda, 0xde, 0xc0, 0x15, 0x0a, 0x38, 0xa5, 0x1a,
	0xbf, 0x0e, 0xb5, 0x73, 0x33, 0xe8, 0xbd, 0x76, 0x42, 0x97, 0x4a, 0x60, 0x86, 0x09, 0x18, 0xce,
	0xcd, 0xe0, 0x25, 0x87, 0x50, 0x15, 0x11, 0x93, 0x5c, 0x3f, 0x2b, 0xec, 0x8a, 0x35, 0x01, 0xa3,
	0xda, 0x19, 0x5b, 0x52, 0x55, 0xb2, 0xa4, 0x94, 0x7d, 0x40, 0x96, 0x7d, 0xac, 0x01, 0xa4, 0x54,
	0xbf, 0x6a, 0x45, 0x6a, 0xdf, 0xfa, 0x21, 0x0f, 0x25, 0xc6, 0x01, 0xd4, 0x82, 0x8a, 0xed, 0x39,
	0xae, 0x65, 0x06, 0x84, 0xb1, 0xbf, 0x82, 0xe3, 0x31, 0x7a, 0x02, 0x15, 0x7a, 0x55, 0xcf, 0x71,
	0xb9, 0xe2, 0xd7, 0xb6, 0x8d, 0xa9, 0xac, 0x64, 0xcc, 0xa1, 0x98, 0x38, 0x5e, 0x83, 0x1e, 0x80,
	0x1e, 0x38, 0x67, 0xae, 0x19, 0x8e, 0x7d, 0xd2, 0x0b, 0x6c, 0xdf, 0x19, 0x85, 0x4c, 0x56, 0x75,
	0x3c, 0x17, 0xc3, 0xbb, 0x0c, 0x4c, 0x8f, 0x11, 0x90, 0xff, 0x1c, 0x13, 0xea, 0x0e, 0x8a, 0x9c,
	0x93, 0xd1, 0x58, 0x66, 0x54, 0xdf, 0x0c, 0x4d, 0x26, 0xa1, 0x84, 0x51, 0x7b, 0x66, 0x68, 0x52,
	0x57, 0x72, 0x69, 0x0e, 0xc7, 0x91, 0xcf, 0xe1, 0x83, 0xd6, 0x67, 0x50, 0x89, 0x4e, 0x95, 0xa9,
	0x62, 0x8b, 0x50, 0x72, 0xdc, 0x3e, 0x79, 0xc3, 0x2e, 0xd7, 0xc0, 0x7c, 0xd0, 0xfa, 0x0e, 0xca,
	0x5c, 0xd0, 0xc9, 0xbc, 0x26, 0xcd, 0x27, 0x7b, 0xe5, 0xa5, 0xbd, 0xd0, 0x1d, 0x68, 0x8c, 0xc6,
	0xd6, 0x2b, 0x72, 0xa5, 0x5e, 0xb4, 0xce, 0x81, 0xfc, 0x96, 0x46, 0x00, 0xf3, 0x12, 0xe3, 0x9e,
	0x3a, 0xc3, 0x90, 0xf8, 0xd4, 0x0f, 0x24, 0x96, 0xae, 0x6d, 0x14, 0x36, 0xab, 0x92, 0x3d, 0xa3,
	0xaf, 0xa0, 0x1a, 0xf1, 0x93, 0xc7, 0x91, 0x77, 0x13, 0x42, 0xb2, 0xc8, 0xf8, 0xb3, 0x06, 0xe8,
	0x88, 0x5c, 0x8c, 0x3c, 0x6f, 0x28, 0xdb, 0xdc, 0xe7, 0x50, 0x93, 0x22, 0x8a, 0x88, 0x6b, 0x99,
	0x91, 0x47, 0xc6, 0xa3, 0x8a, 0x65, 0xf6, 0xfb, 0xa4, 0xcf, 0x95, 0x9e, 0xb3, 0xa0, 0xca, 0x20,
	0x4c, 0xeb, 0x75, 0x28, 0x0c, 0x08, 0x61, 0x97, 0x2f, 0x60, 0xfa, 0x89, 0x36, 0xa0, 0x3e, 0x20,
	0xa4, 0x37, 0x22, 0x7e, 0xcf, 0xba, 0x0a, 0xb9, 0x74, 0x0b, 0x18, 0x06, 0x84, 0x9c, 0x10, 0x7f,
	0xf7, 0x2a, 0x24, 0x52, 0xa4, 0x2a, 0x29, 0x91, 0xea, 0x43, 0x98, 0x0f, 0x42, 0xd3, 0x0f, 0x1d,
	0xf7, 0xac, 0x37, 0xf2, 0x1d, 0xcf, 0x77, 0xc2, 0x2b, 0x26, 0x60, 0x0d, 0xeb, 0xd1, 0xc4, 0x89,
	0x80, 0x1b, 0x7f, 0xd4, 0xa0, 0xf1, 0xc2, 0x0d, 0x46, 0xc4, 0x0d, 0x85, 0xf4, 0x64, 0xed, 0xd5,
	0x7e, 0x82, 0xf6, 0xa6, 0x24, 0x9a, 0x4f, 0x4b, 0x34, 0x51, 0x86, 0x82, 0xac, 0x0c, 0xeb, 0x50,
	0x73, 0x82, 0x5e, 0x6c, 0x57, 0x45, 0x6e, 0xfb, 0x4e, 0xd0, 0x8e, 0x2c, 0xeb, 0x36, 0xd4, 0x85,
	0x79, 0xca, 0x17, 0xaf, 0x71, 0x03, 0x65, 0x20, 0xe3, 0x7f, 0x35, 0x98, 0x67, 0xa1, 0xa9, 0xe3,
	0x85, 0xce, 0xc0, 0xb1, 0x99, 0x61, 0xa3, 0x6d, 0x28, 0x86, 0x57, 0x23, 0x6e, 0xaa, 0xb3, 0xdb,
	0xb7, 0x94, 0x34, 0x44, 0x46, 0xdc, 0x3a, 0xbd, 0x1a, 0x11, 0xcc, 0x70, 0xd1, 0x1d, 0x28, 0xf1,
	0x70, 0xce, 0x6d, 0xb8, 0xa1, 0x2c, 0xc2, 0x7c, 0xce, 0xb8, 0x0f, 0x45, 0xba, 0x04, 0x35, 0xa0,
	0x2a, 0x3b, 0xf1, 0x49, 0xb7, 0xae, 0x19, 0xbf, 0xc8, 0xc3, 0x8a, 0xc4, 0x3f, 0xe5, 0x74, 0x5f,
	0x28, 0xa7, 0xbb, 0x9b, 0xc1, 0xee, 0x69, 0x67, 0xfc, 0x1a, 0x96, 0x84, 0x03, 0xa3, 0xaa, 0x25,
	0xe9, 0x65, 0x7e, 0xaa, 0x5e, 0x1e, 0xe4, 0xf0, 0x62, 0xbc, 0x46, 0xd6, 0xec, 0x63, 0x58, 0x34,
	0x6d, 0x9b, 0x8c, 0xc2, 0x09, 0x52, 0x05, 0x46, 0x2a, 0xf6, 0xec, 0x69, 0x9b, 0x38, 0xc8, 0xe1,
	0x85, 0x68, 0xa5, 0x04, 0x36, 0xee, 0x08, 0xde, 0xd4, 0xa1, 0xb2, 0xd3, 0x6e, 0xef, 0x9f, 0x70,
	0xd6, 0x70, 0x4e, 0x3d, 0x3d, 0xc4, 0x47, 0x94, 0x2f, 0xbb, 0x0d, 0xc5, 0x9e, 0x8c, 0x17, 0x80,
	0x44, 0x88, 0x3c, 0x21, 0xc4, 0xc7, 0xd4, 0x97, 0x05, 0xe1, 0x3b, 0xa6, 0x05, 0x23, 0xe2, 0x5f,
	0x98, 0x2e, 0x11, 0x5e, 0xb7, 0x82, 0x13, 0x80, 0xb1, 0x04, 0x0b, 0x0a, 0xd9, 0x60, 0xe4, 0xb9,
	0x01, 0x31, 0x7e, 0x28, 0xc0, 0x62, 0x97, 0x84, 0x7b, 0xc4, 0x1a, 0x9f, 0x3d, 0x27, 0x97, 0x64,
	0x18, 0x6d, 0xf8, 0x25, 0x94, 0x86, 0x74, 0x2c, 0x44, 0x72, 0x3f, 0xba, 0x7c, 0x16, 0xf2, 0x96,
	0x04, 0xe1, 0xab, 0xd0, 0x1e, 0x54, 0x83, 0xb1, 0x15, 0x5c, 0x05, 0x21, 0xb9, 0x10, 0x89, 0xc2,
	0x07, 0xd7, 0x92, 0xe8, 0x46, 0xd8, 0x38, 0x59, 0x68, 0x1c, 0x03, 0x24, 0x98, 0xa8, 0x0a, 0xa5,
	0x53, 0xbc, 0xd3, 0xde, 0xd7, 0x73, 0xf4, 0x73, 0x6f, 0x7f, 0xf7, 0xc5, 0x33, 0x5d, 0x43, 0x15,
	0x28, 0x1e, 0x76, 0x9e, 0x1e, 0xeb, 0x79, 0xfa, 0xf5, 0x72, 0x07, 0x77, 0xf4, 0x02, 0x9d, 0xde,
	0xc7, 0xf8, 0x18, 0xeb, 0x45, 0xca, 0xfa, 0x36, 0x3e, 0x3c, 0x3d, 0x6c, 0xef, 0x3c, 0xd7, 0x4b,
	0xc6, 0xaf, 0x34, 0xa8, 0xc6, 0x3b, 0xa1, 0x19, 0x28, 0xec, 0x3c, 0x7f, 0xae, 0xe7, 0xe8, 0xca,
	0x9d, 0xbd, 0x6f, 0x31, 0xa7, 0xb6, 0x73, 0xf4, 0x0c, 0x73, 0x6a, 0x6d, 0xfa, 0x55, 0xa0, 0x5f,
	0xbb, 0xed, 0xbd, 0x5d, 0xbd, 0xc8, 0xbe, 0x4e, 0xdb, 0x7b, 0x7a, 0x89, 0xcd, 0x1e, 0xec, 0x74,
	0xf4, 0x32, 0xfd, 0xa2, 0x8a, 0xae, 0xcf, 0xf0, 0x93, 0xec, 0x7d, 0xab, 0x57, 0xe8, 0xd7, 0xd1,
	0x61, 0x07, 0xeb, 0x55, 0xfa, 0x75, 0xb2, 0xbf, 0x8f, 0x75, 0xa0, 0x5f, 0xf8, 0xa4, 0xdd, 0xd5,
	0x6b, 0xf4, 0xab, 0xdb, 0xc6, 0x27, 0x7a, 0x9d, 0x7d, 0xe1, 0x6f, 0xb0, 0xde, 0x60, 0x5f, 0xdf,
	0x75, 0xda, 0xfa, 0x2c, 0xfd, 0x3a, 0xfd, 0xf6, 0xe8, 0x44, 0x9f, 0x33, 0x56, 0x60, 0x69, 0x82,
	0x55, 0x42, 0x68, 0xff, 0x05, 0x4b, 0x7b, 0x4e, 0x60, 0xa7, 0xb5, 0xe4, 0x4e, 0x96, 0x96, 0x1c,
	0xe4, 0x54, 0x3d, 0x59, 0x85, 0x19, 0x86, 0xe4, 0xf0, 0xe4, 0xa8, 0x41, 0x93, 0x52, 0x0a, 0x38,
	0xec, 0xab, 0x2a, 0x54, 0x98, 0x50, 0xa1, 0xdd, 0x32, 0x14, 0x29, 0x9e, 0xd1, 0x84, 0xe5, 0xc9,
	0xed, 0xc5, 0xc1, 0xfe, 0x0d, 0x96, 0x9e, 0x11, 0x97, 0xf8, 0x66, 0x48, 0x98, 0x8f, 0x08, 0xa2,
	0x83, 0xdd, 0x80, 0xaa, 0x6b, 0xf1, 0x9c, 0x3a, 0x10, 0x41, 0xb1, 0xe2, 0x5a, 0x1c, 0x87, 0x95,
	0x0f, 0xe6, 0x95, 0x37, 0x0e, 0xe3, 0x73, 0xe7, 0x99, 0x76, 0x37, 0x38, 0x54, 0x9c, 0xdb, 0x78,
	0x0c, 0xcb, 0x93, 0xc4, 0xf9, 0xb6, 0x92, 0x53, 0xe4, 0x55, 0x93, 0xc6, 0xe3, 0x7c, 0x9c, 0xb5,
	0x90, 0xc0, 0x58, 0x85, 0x95, 0x67, 0x24, 0xdc, 0x25, 0x41, 0x98, 0x14, 0x5e, 0xfc, 0x6c, 0xc6,
	0x0e, 0x34, 0xd3, 0x53, 0x82, 0xf2, 0xbb, 0x15, 0x6f, 0x86, 0x0b, 0x73, 0x94, 0x04, 0x73, 0x8b,
	0xe2, 0xc6, 0x5b, 0x71, 0x7e, 0x2f, 0x16, 0x2f, 0x2a, 0x8b, 0x45, 0xd9, 0x80, 0x23, 0x24, 0x1a,
	0xb3, 0x06, 0xe3, 0xe1, 0xb0, 0xa7, 0x54, 0x75, 0xdc, 0x8a, 0x75, 0x3a, 0x71, 0x2a, 0x17, 0x71,
	0x8f, 0x40, 0x4f, 0xf6, 0x13, 0x47, 0x8d, 0x9d, 0xb5, 0x76, 0x8d, 0xb3, 0x5e, 0x86, 0xc5, 0x68,
	0x61, 0xdb, 0x1b, 0xbb, 0x61, 0xc4, 0x83, 0x2f, 0xa8, 0xe0, 0x14, 0xb8, 0xa0, 0xba, 0x0e, 0x9c,
	0x8d, 0x3d, 0x9b, 0x82, 0x85, 0xe8, 0x78, 0x86, 0xc8, 0x10, 0x8d, 0x7d, 0x58, 0x88, 0x56, 0x4a,
	0x4c, 0x7d, 0xdf, 0xeb, 0x1b, 0x5f, 0x26, 0x07, 0xfb, 0x29, 0x02, 0x68, 0x52, 0xdd, 0x08, 0x23,
	0xf5, 0x90, 0xa5, 0xfb, 0x7b, 0x8d, 0x49, 0x5e, 0x9d, 0x12, 0xc4, 0x5b, 0x50, 0x39, 0x13, 0xf0,
	0x28, 0x85, 0x8d, 0xc6, 0x34, 0x5d, 0x71, 0xad, 0xde, 0x6b, 0xcf, 0x7f, 0x45, 0xfc, 0x40, 0x54,
	0xc2, 0x55, 0xd7, 0x7a, 0xc9, 0x01, 0x74, 0x29, 0x55, 0x36, 0xb6, 0x94, 0x1a, 0x4a, 0x11, 0xc7,
	0xe3, 0x89, 0x12, 0xb3, 0x98, 0x2a, 0x31, 0x3f, 0x83, 0x65, 0xd7, 0xea, 0xd1, 0x10, 0xa2, 0xc6,
	0x99, 0x80, 0x45, 0xf3, 0x06, 0x5e, 0x74, 0xad, 0x13, 0x36, 0xa9, 0xc8, 0xfc, 0x2b, 0x98, 0x7f,
	0x46, 0x42, 0x11, 0x7b, 0x22, 0x36, 0x67, 0x6a, 0x8d, 0x36, 0x45, 0x6b, 0xfe, 0x5b, 0x03, 0x24,
	0x93, 0x10, 0x5c, 0xc8, 0xee, 0x3c, 0x68, 0xd3, 0x3a, 0x0f, 0x4f, 0x26, 0x3a, 0x0f, 0x79, 0xb5,
	0xec, 0x49, 0x07, 0xc7, 0x89, 0x06, 0xc4, 0x0a, 0x53, 0x35, 0x81, 0x26, 0x4b, 0xea, 0xdf, 0x99,
	0x0c, 0x95, 0x09, 0x71, 0xc2, 0xfb, 0x30, 0xe7, 0x5a, 0xe9, 0x3b, 0x36, 0xf0, 0xac, 0x6b, 0xc9,
	0x37, 0x44, 0xab, 0x50, 0xa1, 0x6e, 0xe6, 0x2a, 0x24, 0x5c, 0x64, 0x45, 0x3c, 0xe3, 0x5a, 0x34,
	0x55, 0x0c, 0x84, 0xe6, 0x1f, 0x39, 0xae, 0xe3, 0x9e, 0xc9, 0xbb, 0xfe, 0x29, 0xcf, 0xcf, 0x23,
	0x4d, 0x88, 0x5d, 0x1f, 0x80, 0xee, 0x92, 0x90, 0x6a, 0x40, 0x2f, 0x16, 0xb5, 0xc6, 0x88, 0xce,
	0x09, 0xf8, 0x41, 0x24, 0xf1, 0x87, 0xb0, 0x68, 0x8f, 0x7d, 0x9f, 0xb8, 0x71, 0xdf, 0x40, 0x6e,
	0xa0, 0x20, 0x31, 0xb7, 0x9b, 0x24, 0x69, 0xe8, 0x23, 0x40, 0xea, 0x8a, 0xc0, 0xf9, 0x3e, 0xd2,
	0x24, 0x5d, 0xc6, 0xef, 0x3a, 0xdf, 0x67, 0xd0, 0x7f, 0xcd, 0xe9, 0x17, 0x19, 0xbe, 0x42, 0xff,
	0x25, 0xa7, 0xbf, 0x03, 0x6b, 0xea, 0x8a, 0x49, 0x06, 0x72, 0x55, 0x6b, 0xc9, 0x4b, 0x3b, 0x2a,
	0x33, 0x55, 0x35, 0x2e, 0xa7, 0xd4, 0x78, 0x19, 0xca, 0xc4, 0xf7, 0x3d, 0x9f, 0x97, 0xa8, 0x55,
	0x2c, 0x46, 0xc6, 0x4b, 0x58, 0x7d, 0x46, 0xc2, 0x4e, 0xc2, 0x22, 0x6c, 0x86, 0x24, 0x52, 0xd8,
	0x35, 0x00, 0xe2, 0xf6, 0x23, 0xfe, 0x68, 0xdc, 0xac, 0x88, 0xdb, 0x17, 0x6c, 0x51, 0xe2, 0x04,
	0xe7, 0x5e, 0x1c, 0x27, 0x8c, 0x2f, 0xa0, 0x95, 0x45, 0x38, 0x31, 0xe6, 0x09, 0x31, 0xc5, 0x63,
	0xa1, 0x73, 0x62, 0xa5, 0x2c, 0xfd, 0xdf, 0xe6, 0x99, 0xd2, 0x29, 0x33, 0x82, 0xde, 0xd7, 0x50,
	0xb3, 0x9c, 0x90, 0xa6, 0xe2, 0x3d, 0x97, 0x84, 0x22, 0x0d, 0x7a, 0x10, 0xa9, 0x79, 0xf6, 0xa2,
	0xad, 0x5d, 0xbe, 0xa2, 0x43, 0x42, 0x0c, 0x56, 0xfc, 0xcd, 0xbc, 0x28, 0x09, 0x42, 0x55, 0x2d,
	0x80, 0x82, 0xc4, 0xbd, 0xd7, 0xa1, 0x46, 0xcb, 0xa2, 0x9e, 0x37, 0x18, 0x04, 0x24, 0x14, 0x35,
	0x01, 0x50, 0xd0, 0x31, 0x83, 0xbc, 0xd5, 0xa7, 0xc8, 0xb7, 0x2f, 0x4d, 0xf8, 0xa3, 0x1b, 0x50,
	0xf5, 0xc9, 0xd0, 0xbc, 0xea, 0xd1, 0x02, 0x8b, 0xcb, 0xb1, 0xc2, 0x00, 0x4f, 0x09, 0x31, 0xbe,
	0x02, 0x48, 0x0e, 0x8d, 0x6a, 0x30, 0x73, 0xb4, 0x73, 0xd8, 0xe9, 0xec, 0x9f, 0xea, 0x39, 0x3a,
	0x38, 0xdd, 0xef, 0x9e, 0xd2, 0x81, 0x46, 0xf3, 0x28, 0x31, 0xf8, 0x54, 0xcf, 0x23, 0x80, 0x72,
	0xf7, 0xf0, 0x88, 0xce, 0x14, 0x8c, 0x8f, 0x59, 0xf0, 0xa3, 0x79, 0x40, 0x1c, 0xee, 0x95, 0x3c,
	0x42, 0x9b, 0x4c, 0x45, 0xff, 0xa7, 0xcc, 0xc2, 0x97, 0x58, 0x21, 0xd8, 0xfd, 0x08, 0x4a, 0x34,
	0xb9, 0xe0, 0x8e, 0xa7, 0xb6, 0x7d, 0x5b, 0x62, 0xb4, 0x82, 0xb8, 0x45, 0x47, 0x8c, 0xe7, 0x1c,
	0xbf, 0xf5, 0x63, 0x09, 0x2a, 0x11, 0x0c, 0xcd, 0x42, 0xde, 0xe9, 0x0b, 0xb5, 0xca, 0x3b, 0x7d,
	0xb9, 0x93, 0x95, 0x57, 0x3b, 0x59, 0x77, 0xa0, 0x41, 0x63, 0xcf, 0x30, 0xce, 0x39, 0x0a, 0x6c,
	0xbe, 0xce, 0x80, 0x52, 0x23, 0x2c, 0x6a, 0x15, 0xf1, 0xde, 0x42, 0xdc, 0x2a, 0x5a, 0x03, 0x18,
	0x07, 0x34, 0xd3, 0x3a, 0xa3, 0x57, 0x2c, 0xb1, 0xb5, 0x55, 0x0a, 0xd9, 0xa1, 0x00, 0xde, 0x95,
	0xf0, 0x2f, 0x1d, 0x9b, 0x04, 0x8c, 0xe3, 0x55, 0x1c, 0x8f, 0x29, 0x51, 0xc7, 0xb5, 0xbc, 0xb1,
	0xdb, 0x17, 0xbd, 0x9d, 0x68, 0x48, 0x05, 0x15, 0x5c, 0xb9, 0x76, 0xcf, 0xf5, 0xfa, 0xbc, 0xb7,
	0x59, 0xc1, 0x15, 0x0a, 0xe8, 0x78, 0x7d, 0x49, 0x8a, 0xe1, 0x1b, 0xde, 0xda, 0xac, 0x08, 0x29,
	0x9e, 0xbe, 0x09, 0xd0, 0x5d, 0x98, 0x1d, 0x9a, 0x41, 0xd8, 0x0b, 0xa8, 0x71, 0xb1, 0x02, 0x1b,
	0x98, 0x0a, 0xd5, 0x29, 0xb4, 0x4b, 0x5c, 0x5e, 0x63, 0x47, 0x58, 0x3e, 0xb1, 0x2f, 0x39, 0x56,
	0x2d, 0xc1, 0xc2, 0xc4, 0xbe, 0x64, 0x58, 0xf7, 0x61, 0x4e, 0xe4, 0x76, 0x34, 0x1c, 0x30, 0xb4,
	0x3a, 0x43, 0x9b, 0x4d, 0xc0, 0x0c, 0x71, 0x0d, 0x80, 0xb9, 0x5a, 0xba, 0x6b, 0xd8, 0x6c, 0x30,
	0xad, 0xab, 0x32, 0x48, 0x97, 0xf2, 0xe0, 0x1e, 0xcc, 0xf2, 0x69, 0x9f, 0xd8, 0xc4, 0xb9, 0x24,
	0xfd, 0xe6, 0x2c, 0x43, 0x69, 0x30, 0x28, 0x16, 0xc0, 0x49, 0xd5, 0x9f, 0x4b, 0xa9, 0x7e, 0x74,
	0xea, 0x11, 0x2d, 0xe7, 0xd9, 0x71, 0xf4, 0xe4, 0xd4, 0x27, 0x8e, 0x7b, 0xc6, 0x0e, 0xb3, 0x09,
	0x7a, 0x82, 0x75, 0xe1, 0xd8, 0xbe, 0x17, 0x34, 0xe7, 0xf9, 0xb1, 0x23, 0xbc, 0x23, 0x06, 0xa5,
	0xf7, 0x8b, 0xbb, 0x03, 0xc2, 0x20, 0x11, 0x53, 0x98, 0xd9, 0x08, 0x2c, 0x8c, 0xf2, 0x1e, 0xcc,
	0x46, 0x3e, 0x54, 0xe0, 0x2d, 0x88, 0x8e, 0x19, 0x87, 0x26, 0x3e, 0xcb, 0x32, 0xdd, 0x5e, 0x60,
	0x7b, 0x3e, 0x69, 0x2e, 0x72, 0x9f, 0x65, 0x99, 0x6e, 0x97, 0x8e, 0x29, 0x8f, 0x06, 0x84, 0xf4,
	0x06, 0xac, 0x63, 0xd3, 0x5c, 0xe2, 0x5d, 0x8f, 0x01, 0x21, 0xbc, 0x85, 0x63, 0xec, 0xb1, 0x88,
	0x8c, 0xcd, 0xd7, 0x3f, 0x27, 0x77, 0x34, 0x3e, 0x64, 0x39, 0x58, 0x42, 0x45, 0x98, 0xd4, 0xa2,
	0x9c, 0x11, 0xd6, 0xd5, 0x14, 0x10, 0x9b, 0xaf, 0xd5, 0x54, 0xc2, 0x78, 0xcc, 0x7c, 0xa4, 0x0c,
	0x17, 0x64, 0x8c, 0x89, 0x80, 0xcf, 0x33, 0x03, 0x35, 0xa8, 0x6f, 0xb1, 0x1c, 0x1a, 0x9b, 0xaf,
	0xe5, 0xb8, 0x2f, 0x6e, 0x93, 0xd1, 0x40, 0x33, 0xbe, 0x64, 0x31, 0x62, 0x12, 0x5f, 0x6c, 0xb8,
	0x91, 0x6e, 0x30, 0xd5, 0x95, 0x5e, 0x92, 0xb8, 0x43, 0x97, 0x55, 0x71, 0xb2, 0x3b, 0xff, 0x03,
	0x0f, 0xe6, 0xf2, 0x84, 0xa0, 0x29, 0x59, 0xb2, 0xa6, 0x5a, 0xf2, 0x03, 0xd0, 0xd9, 0xd3, 0x8d,
	0xed, 0x0d, 0x7b, 0x11, 0x0a, 0x6f, 0xeb, 0xcd, 0x45, 0xf0, 0x6f, 0x04, 0xea, 0x16, 0x2c, 0x44,
	0x0a, 0xc1, 0x54, 0xf6, 0xc2, 0x19, 0x0e, 0x9d, 0x40, 0x78, 0xeb, 0x79, 0x31, 0x45, 0xb5, 0xf1,
	0x88, 0x4d, 0xd0, 0xba, 0xc4, 0x1f, 0xbb, 0x6e, 0xac, 0xb7, 0xbc, 0x83, 0x55, 0x13, 0x30, 0xa6,
	0xb6, 0x0f, 0x61, 0x31, 0xf4, 0x42, 0x73, 0xd8, 0x9b, 0x30, 0x15, 0xee, 0xc3, 0x11, 0x9b, 0xdb,
	0x55, 0xec, 0x65, 0x13, 0x74, 0x79, 0x05, 0xb3, 0xbd, 0x32, 0xc3, 0x9e, 0x4d, 0xb0, 0x99, 0x01,
	0x2e, 0x42, 0x69, 0xe4, 0x7b, 0x6f, 0xae, 0x44, 0x7c, 0xe6, 0x03, 0xaa, 0xd5, 0xae, 0xd5, 0x4b,
	0x4c, 0x39, 0x10, 0xaf, 0x28, 0x0d, 0xd7, 0x6a, 0x27, 0x40, 0xe3, 0x43, 0xc6, 0xc9, 0x77, 0x14,
	0xe7, 0x31, 0x8b, 0xa2, 0x59, 0xb2, 0xfc, 0x69, 0xcd, 0x42, 0xe3, 0x18, 0xe6, 0x31, 0xb9, 0xf0,
	0x2e, 0x09, 0x75, 0x7d, 0xef, 0xd1, 0x03, 0x59, 0x99, 0xa8, 0x6d, 0xa3, 0xca, 0xd6, 0x58, 0x04,
	0x24, 0x13, 0x14, 0xf5, 0x6a, 0x1b, 0x16, 0x30, 0x09, 0x6c, 0xd3, 0x55, 0xab, 0xd5, 0x8f, 0xa0,
	0x1c, 0x97, 0xaa, 0x85, 0xa9, 0xe6, 0x27, 0x70, 0x8c, 0x1f, 0x35, 0x58, 0xe5, 0x54, 0xe4, 0xf4,
	0x29, 0xa2, 0xf5, 0x39, 0xd4, 0x98, 0x5b, 0xe9, 0xc9, 0xc5, 0x59, 0x36, 0x41, 0x60, 0x88, 0xfc,
	0xad, 0xec, 0x53, 0x80, 0x20, 0xf4, 0x46, 0x3d, 0xb9, 0xff, 0x96, 0xbd, 0xaa, 0x4a, 0xf1, 0xf8,
	0xa2, 0x4f, 0xa0, 0x2c, 0x1c, 0x0d, 0xef, 0x58, 0x65, 0xbd, 0x5f, 0x70, 0xc7, 0x83, 0x05, 0xa2,
	0x71, 0x09, 0xa8, 0x9b, 0x54, 0x47, 0xd1, 0xa1, 0x7f, 0x46, 0x61, 0x94, 0x2e, 0xe6, 0x0b, 0x59,
	0xc5, 0xfc, 0x12, 0x2c, 0x28, 0xfb, 0x0a, 0x81, 0x5c, 0xc1, 0x6a, 0x97, 0x98, 0xbe, 0x7d, 0x9e,
	0xc5, 0xca, 0xe9, 0xcf, 0x52, 0x08, 0x8a, 0xc1, 0x2b, 0x67, 0x24, 0x4e, 0xc3, 0xbe, 0xa9, 0xf6,
	0x0f, 0x9d, 0x0b, 0x27, 0x14, 0x8f, 0x3c, 0x7c, 0x40, 0x69, 0x10, 0xd7, 0xf6, 0xfa, 0xa4, 0x2f,
	0x9a, 0xab, 0xd1, 0xd0, 0xf0, 0xa0, 0x95, 0xb5, 0x75, 0x9c, 0x9e, 0xa4, 0x9d, 0xe0, 0xbb, 0xbc,
	0xb7, 0xca, 0x1b, 0xf2, 0xc7, 0xdc, 0x78, 0xc3, 0x7f, 0x84, 0x66, 0x77, 0x6c, 0x5d, 0x38, 0x59,
	0x46, 0xf6, 0x76, 0x17, 0xf8, 0x31, 0xac, 0x66, 0xac, 0x16, 0xa7, 0xcd, 0xb2, 0xd1, 0x0b, 0x58,
	0x7b, 0x46, 0x22, 0xfe, 0xbf, 0x1f, 0x7b, 0x57, 0x60, 0xc6, 0xb5, 0x7a, 0x31, 0x87, 0x1b, 0xb8,
	0xec, 0x5a, 0x5d, 0xca, 0x63, 0x5e, 0x6f, 0x0d, 0x48, 0x68, 0x9f, 0x33, 0x36, 0x37, 0x68, 0xbd,
	0xf5, 0x94, 0x0e, 0x8d, 0x5f, 0x6b, 0x70, 0x6b, 0xda, 0x7e, 0x71, 0x86, 0xbd, 0x9c, 0xd9, 0xba,
	0xbd, 0x96, 0xbb, 0x4b, 0x59, 0x9d, 0xdb, 0x00, 0x75, 0xa0, 0x39, 0x76, 0xa7, 0x50, 0xcb, 0x4f,
	0xa7, 0xb6, 0x22, 0x2d, 0x52, 0x6a, 0xe5, 0xc7, 0xb0, 0x9e, 0x9c, 0x5e, 0x79, 0x1e, 0x78, 0x3b,
	0xbf, 0x8c, 0x2e, 0x6c, 0x4c, 0x5f, 0x2c, 0x2e, 0xff, 0x71, 0xf2, 0x70, 0xc8, 0x6f, 0xbb, 0x14,
	0x9d, 0x4f, 0x59, 0x10, 0xbf, 0x19, 0x1a, 0x7f, 0x07, 0x88, 0x0b, 0x5c, 0x49, 0x15, 0xb2, 0x63,
	0xfc, 0x03, 0x58, 0x50, 0x70, 0xaf, 0x51, 0x8b, 0x7d, 0x58, 0xee, 0x8e, 0xad, 0xc0, 0xf6, 0x1d,
	0x6b, 0xa2, 0x67, 0xf7, 0x5e, 0xbd, 0x85, 0xdf, 0x68, 0x70, 0x33, 0xa6, 0x93, 0xa5, 0x5d, 0x8f,
	0x78, 0x43, 0x98, 0xcd, 0x0b, 0x2f, 0x78, 0x8d, 0x7b, 0x4a, 0x70, 0xd1, 0x63, 0xa8, 0x8d, 0xdd,
	0x64, 0x69, 0xfe, 0x6d, 0x4b, 0x65, 0x6c, 0x9a, 0xeb, 0x39, 0xae, 0x3d, 0x1c, 0xf7, 0x49, 0xef,
	0x82, 0xa7, 0x35, 0xa2, 0xad, 0x39, 0x2b, 0xc0, 0x22, 0xd9, 0x31, 0x16, 0x60, 0xbe, 0x1b, 0x7a,
	0xa3, 0x3d, 0x93, 0x5c, 0xc4, 0x56, 0x48, 0x83, 0x86, 0x0c, 0xe4, 0x5c, 0xdc, 0xfe, 0x7f, 0x1d,
	0x8a, 0x56, 0x68, 0xf7, 0x51, 0x07, 0x1a, 0x4a, 0xb2, 0x81, 0x6e, 0x4a, 0x45, 0x4b, 0x2a, 0x39,
	0x69, 0xad, 0x4d, 0x99, 0x15, 0xae, 0x2f, 0x47, 0xe9, 0x29, 0xfd, 0xde, 0x84, 0x5e, 0x56, 0xc7,
	0x3c, 0xa1, 0x97, 0xdd, 0x24, 0xce, 0xa1, 0x7d, 0x80, 0xe4, 0xf8, 0x28, 0x66, 0x59, 0xea, 0x9e,
	0xad, 0x56, 0xd6, 0x54, 0x4c, 0xe6, 0x5f, 0x60, 0x56, 0xad, 0x76, 0xd1, 0xda, 0xb4, 0x2a, 0x98,
	0x93, 0xbb, 0x75, 0x7d, 0x91, 0x6c, 0xe4, 0xd0, 0x7f, 0xb0, 0xb4, 0x77, 0xa2, 0x92, 0x47, 0xb7,
	0xd3, 0xeb, 0x26, 0xda, 0x07, 0x2d, 0xe3, 0x3a, 0x94, 0x89, 0x13, 0x4b, 0x9d, 0x24, 0xe5, 0xc4,
	0xe9, 0xd6, 0x93, 0x72, 0xe2, 0x8c, 0x06, 0x14, 0xe7, 0x65, 0x32, 0x97, 0xf0, 0x32, 0xd5, 0x91,
	0x4b, 0x78, 0x99, 0xee, 0xb4, 0x71, 0x11, 0x2b, 0x49, 0xb6, 0xa2, 0x32, 0xa9, 0x9c, 0x5c, 0x51,
	0x99, 0x74, 0x66, 0x6e, 0xe4, 0xd0, 0x4b, 0xde, 0x08, 0x96, 0x7b, 0xd7, 0x68, 0x5d, 0x5a, 0x94,
	0xd5, 0xf0, 0x6e, 0x6d, 0x4c, 0x47, 0x88, 0x09, 0xff, 0x33, 0xd4, 0xe5, 0x7e, 0x2c, 0xba, 0x21,
	0xaf, 0x99, 0x24, 0x78, 0x33, 0x7b, 0x32, 0x26, 0xf6, 0x4f, 0x50, 0x89, 0x66, 0xd0, 0xca, 0x24,
	0x6e, 0x44, 0xa4, 0x99, 0x9e, 0x88, 0x09, 0x1c, 0x40, 0x4d, 0x2a, 0x70, 0x50, 0x4b, 0x65, 0x8b,
	0x42, 0xe6, 0x46, 0xe6, 0x9c, 0x4c, 0x49, 0xf2, 0x8c, 0x09, 0xa5, 0xb4, 0x6b, 0x4d, 0x28, 0x65,
	0xb8, 0xd2, 0x58, 0xc9, 0xe4, 0xe7, 0x43, 0x59, 0x5a, 0xe9, 0x98, 0xae, 0x28, 0x59, 0x46, 0xd0,
	0x36, 0x72, 0xe8, 0x5f, 0x59, 0x8b, 0x57, 0xad, 0x8a, 0xd0, 0x86, 0x7a, 0xa1, 0x0c, 0xc2, 0xb7,
	0xaf, 0xc1, 0x88, 0x69, 0x9f, 0xd0, 0x04, 0x78, 0x32, 0x49, 0x4d, 0x4c, 0x6e, 0x6a, 0x02, 0xdb,
	0xca, 0x8a, 0x9b, 0x46, 0xee, 0xa1, 0x46, 0x4f, 0x9b, 0xca, 0x40, 0x92, 0xd3, 0x4e, 0x4b, 0x6d,
	0x92, 0xd3, 0x4e, 0x4d, 0x5f, 0x8c, 0x1c, 0x72, 0x58, 0x41, 0x91, 0x91, 0x3c, 0xa0, 0x7b, 0xd2,
	0x65, 0xa7, 0x27, 0x33, 0xad, 0x0f, 0xde, 0x86, 0x16, 0x6f, 0xe5, 0xb1, 0xd2, 0x35, 0x33, 0x58,
	0xa3, 0xfb, 0x69, 0x2a, 0x99, 0xb9, 0x40, 0x6b, 0xf3, 0xed, 0x88, 0xf1, 0x86, 0x7d, 0x58, 0xca,
	0x8c, 0x94, 0xe8, 0xae, 0xc4, 0x99, 0xa9, 0x81, 0xb4, 0xb5, 0xfe, 0x96, 0xc7, 0x71, 0x23, 0xb7,
	0xa9, 0x3d, 0xd4, 0xd0, 0x09, 0xcc, 0x4d, 0xc4, 0x75, 0x74, 0x2b, 0x45, 0x5f, 0x09, 0xf8, 0xad,
	0xd5, 0xa9, 0x3f, 0x05, 0x30, 0x79, 0x73, 0x2b, 0x66, 0xcd, 0x38, 0xc5, 0x8a, 0xe5, 0xce, 0x9f,
	0x62, 0xc5, 0x4a, 0xdf, 0x8e, 0xdb, 0x9e, 0xf4, 0x04, 0x9d, 0xd8, 0x5e, 0xfa, 0xb9, 0x3b, 0xb1,
	0xbd, 0xac, 0x37, 0x6b, 0x66, 0x7b, 0xea, 0x0b, 0x64, 0x62, 0x7b, 0x99, 0x0f, 0xa3, 0x89, 0xed,
	0x4d, 0x79, 0xb8, 0x8c, 0x3c, 0x73, 0xf2, 0x0c, 0xa0, 0x78, 0xe6, 0xd4, 0xb3, 0x81, 0xe2, 0x99,
	0xd3, 0x6f, 0x07, 0x46, 0x6e, 0xfb, 0xaf, 0x1a, 0xcc, 0xf8, 0xe4, 0x2c, 0xa4, 0xb9, 0x0f, 0x75,
	0x3a, 0x49, 0xb1, 0x23, 0x39, 0x9d, 0x54, 0xe5, 0x25, 0x39, 0x9d, 0x8c, 0xea, 0x28, 0x87, 0x4e,
	0x59, 0xaf, 0x55, 0x7e, 0xcc, 0x42, 0xb2, 0x5b, 0xc9, 0x78, 0x00, 0x6b, 0xad, 0x4f, 0x9d, 0x57,
	0x5d, 0x99, 0xfc, 0xb2, 0x2a, 0xbb, 0xb2, 0x8c, 0xe7, 0x5c, 0xd9, 0x95, 0x65, 0x3d, 0xc8, 0x1a,
	0x39, 0xab, 0xcc, 0x7a, 0x27, 0x9f, 0xfe, 0x2d, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x64, 0x56, 0xac,
	0x1e, 0x2b, 0x00, 0x00,
}
